<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-08-17T07:31:13.568Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[线程池应用及实现原理剖析]]></title>
        <id>https://www.sunjianbo.com/thread-pool/</id>
        <link href="https://www.sunjianbo.com/thread-pool/">
        </link>
        <updated>2020-08-17T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="为什么要用线程池">为什么要用线程池</h2>
<p>线程是不是越多越好?</p>
<ol>
<li>线程在java中是一个对象,更是操作系统的资源,线程创建、销毁需要时间。如果创建时间+销毁时间&gt;执行任务时间就很不合算。</li>
<li>java对象占用堆内存,操作系统线程占用系统内存,根据jνm规范,一个线程默认最大栈大小1M,这个栈空间是需要从系统内存中分配的。线程过多,会消耗很多的內存。</li>
<li>操作系统需要频繁切换线程上下文(大家都想被运行),影响性能。</li>
</ol>
<p>线程池的推出,就是为了方便的控制线程数量。</p>
<h2 id="线程池原理-概念">线程池原理 - 概念</h2>
<h4 id="线程池管理器">线程池管理器</h4>
<p>用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务;</p>
<h4 id="工作线程">工作线程</h4>
<p>线程池中线程,在没有任务时处于等待状态,可以循环的执行任务;</p>
<h4 id="任务接口">任务接口</h4>
<p>每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行完后的收尾工作,任务的执行状态等;</p>
<h4 id="任务队列">任务队列</h4>
<p>用于存放没有处理的任务。提供一种缓冲机制。</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200805095038062.png" alt="" loading="lazy"></figure>
<h2 id="线程池api-接口定义和实现类">线程池API - 接口定义和实现类</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td>Executor</td>
<td>最上层的接口,定义了<font color=red>执行任务的方法 execute</font></td>
</tr>
<tr>
<td>接口</td>
<td>ExecutorService</td>
<td>继承了 Executor接口,拓展了 Callable、 Future、关闭方法</td>
</tr>
<tr>
<td>接口</td>
<td>ScheduledExecutorService</td>
<td>继承了 ExecutorService,增加了定时任务相关的方法</td>
</tr>
<tr>
<td>实现类</td>
<td>ThreadPoolExecutor</td>
<td><font color=red>基础、标准的线程池实现</font></td>
</tr>
<tr>
<td>实现类</td>
<td>ScheduledThreadPoolExecutor</td>
<td>继承了 ThreadPoolExecutor,实现了ScheduledExecutorService中相关<font color=red>定时任务</font>的方法</td>
</tr>
</tbody>
</table>
<h2 id="线程池api-方法定义">线程池API - 方法定义</h2>
<h3 id="executorservice">ExecutorService</h3>
<pre><code class="language-java">//监测ExecutorService是否已经关闭， 直到所有任务完成执行，或超时发生，或当前线程被中断
awaitTermination(long timeout, TimeUnit unit)
//执行给定的任务集合，执行完毕后，返回结果
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务集合，执行完毕或者超时后，返回结果，其他任务终止
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//执行给定的任务，任意一个执行成功则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务，任意一个执行成功或者超时后，则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//如果此线程池已关闭，则返回true。
isShutdown()
//如果关闭后所有任务都已完成，则返回true。
isTerminated()
//优雅关闭线程池，之前提交的任务将被执行，但是不会接受新的任务。
shutdown()
//尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行任务的列表。
shutdownNow()
//提交个用于执行的Callable返回任务，并返回一个Future,用于获取Callable执行结果
submit(Callable&lt;T&gt; task)
//提交可运行任务以执行，并发回一个Future对象，执行结果为null
submit(Runnable task)
//提交可运行任务以执行，并返回Future, 执行结果为传入的result
submit(Runnable task, T result)
</code></pre>
<h3 id="scheduledexecutorservice">ScheduledExecutorService</h3>
<ul>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务过了给定的初始延迟时间,会第一次被执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会等到该次任务执行结束后,立刻执行,这也是它和<code>scheduleWithFixedDelay</code>的重要区别。<br>
此处结合代码示例进行理解即可!</p>
</li>
<li>
<p><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务,过了初始延迟时间,第一次被执行,后续以给定的周期时间执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会在该次任务执行结束的时间基础上,计算执行延时。</p>
<p>对于超过周期的长时间处理任务的不同处理方式,这是它和<code>scheduleAtFixedRate</code>的重要区别。</p>
</li>
</ul>
<h2 id="线程池api-executors工具类">线程池API - Executors工具类</h2>
<p>你可以自己实例化线程池,也可以用 Executors创建线程池的工厂类,常用方法如下:</p>
<h3 id="newfixedthreadpoolint-nthreads">newFixedThreadPool(int nThreads)</h3>
<p>创建一个固定大小、任务队列容量无界的线程池。核心线程数=最大线程数。</p>
<h3 id="newcachedthreadpool">newCachedThreadPool()</h3>
<p>创建的是一个大小无界的缓冲线程池。它的任务队列是一个同步队列。</p>
<p>任务加入到池中,如果池中有空闲线程,则用空闲线程执行,如无则创建新线程执行。</p>
<p>池中的线程空闲超过60秒,将被销毁释放。线程数随任务的多少变化。</p>
<p>适用于执行耗时较小的异步任务。池的核心线程数=0,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h3 id="newsinglethreadexecutor">newSingleThreadExecutor()</h3>
<p>只有一个线程来执行无界任务队列的单一线程池。</p>
<p>该线程池确保任务按加入的顺序一个个依次执行。当唯一的线程因任务异常中止时,将创建一个新的线程来继续执行后续的任务。</p>
<p>与 <code>newFixedThreadPool(1)</code>的区别在于,单一线程池的池大小在<code>newSingleThreadExecutor</code>方法中硬编码,不能再改变的。</p>
<h3 id="newscheduledthreadpoolint-corepoolsize">newScheduledThreadPool(int corePoolSize)</h3>
<p>能定时执行任务的线程池。该池的核心线程数由参数指定,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h2 id="线程池原理-任务execute过程">线程池原理-任务execute过程</h2>
<ol>
<li>
<p>是否达到核心线程数量?</p>
<p>没达到,创建一个工作线程来执行任务。</p>
</li>
<li>
<p>工作队列是否已满?</p>
<p>没满,则将新提交的任务存储在工作队列里。</p>
</li>
<li>
<p>是否达到线程池最大数量?</p>
<p>没达到,则创建一个新的工作线程来执行任务。</p>
</li>
<li>
<p>最后,执行拒绝策略来处理这个任务。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200806112820086.png" alt="" loading="lazy"></figure>
<h2 id="实践-合适的线程数量">实践 - 合适的线程数量</h2>
<p>如何确定合适数量的线程?</p>
<ul>
<li>
<p>计算型任务:</p>
<p>CPU数量的1-2倍</p>
</li>
<li>
<p>IO型任务:</p>
<p>相对比计算型任务,需多一些线程,要根据具体的<u>IO阻塞时长</u>进行考量决定。<br>
如 tomcat中默认的最大线程数为: 200。</p>
</li>
</ul>
<p>也可考虑根据需要在一个<u>最小数量和最大数量间</u>自动增减线程数。(<code>newCachedThreadPool</code>)</p>
<h2 id="代码示例">代码示例:</h2>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/** 线程池的使用 */
public class Demo9 {

	/**
	 * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况
	 * 
	 * @param threadPoolExecutor 传入不同的线程池，看不同的结果
	 * @throws Exception
	 */
	public void testCommon(ThreadPoolExecutor threadPoolExecutor) throws Exception {
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 查看线程数量，查看队列等待数量
		Thread.sleep(500L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
		// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）
		Thread.sleep(15000L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
	}

	/**
	 * 标准线程池
	 * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest1() throws Exception {
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());

		testCommon(threadPoolExecutor);
		// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 有拒绝策略的
	 * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest2() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 5个任务直接分配线程开始执行
		// 2、 3个任务进入等待队列
		// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)
		// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。
		// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程
	}

	/**
	 * 自定义Executors.newFixedThreadPool(int nThreads)
	 * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest3() throws Exception {
		// 和Executors.newFixedThreadPool(int nThreads)一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 自定义Executors.newCachedThreadPool()
	 * 4、 线程池信息：
	 * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest4() throws Exception {

		// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。
		// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，
		// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，
		// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。
		// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。

		// 和Executors.newCachedThreadPool()一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
				new SynchronousQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行
		// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0
		Thread.sleep(60000L);
		System.out.println(&quot;60秒后，再看线程池中的数量：&quot; + threadPoolExecutor.getPoolSize());
	}

	/**
	 * 延迟执行
	 * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest5() throws Exception {
		// 和Executors.newScheduledThreadPool()一样的
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		threadPoolExecutor.schedule(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;任务被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 3000, TimeUnit.MILLISECONDS);
		System.out.println(
				&quot;定时任务，提交成功，时间是：&quot; + System.currentTimeMillis() + &quot;, 当前线程池中线程数量：&quot; + threadPoolExecutor.getPoolSize());
		// 预计结果：任务在3秒后被执行一次
	}

	/**
	 * 周期性执行
	 * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest6() throws Exception {
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。
		// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别
		// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。
		// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）
		threadPoolExecutor.scheduleAtFixedRate(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-1 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);

		// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。
		// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）
		threadPoolExecutor.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-2 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	/**
	 * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest7() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		threadPoolExecutor.shutdown();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdown后，不接收新的任务，等待13任务执行结束
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	/**
	 * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest8() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		System.out.println(&quot;未结束的任务有：&quot; + shutdownNow.size());

		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	public static void main(String[] args) throws Exception {
		new Demo9().threadPoolExecutorTest1();
//		new Demo9().threadPoolExecutorTest2();
//		new Demo9().threadPoolExecutorTest3();
//		new Demo9().threadPoolExecutorTest4();
//		new Demo9().threadPoolExecutorTest5();
//		new Demo9().threadPoolExecutorTest6();
//		new Demo9().threadPoolExecutorTest7();
//		new Demo9().threadPoolExecutorTest8();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程封闭之ThreadLocal和栈封闭]]></title>
        <id>https://www.sunjianbo.com/thread-closure/</id>
        <link href="https://www.sunjianbo.com/thread-closure/">
        </link>
        <updated>2020-08-14T08:42:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程封闭的概念">线程封闭的概念</h2>
<p>多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，所以线程封闭概念就提出来了。</p>
<p>数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p>
<p>线程封闭具体的体现有： <strong>Thread Local</strong>、<strong>局部变量</strong></p>
<h2 id="threadlocal">ThreadLocal</h2>
<p>它是一个线程级别变量，每个线程都有一个 Thread Local,就是每个线程都拥有了自己独立的一个变量,竞争条件被彻底消除了，在并发模式下是绝对安全的变量。</p>
<p>用法： ThreadLocal<T>var= new ThreadLocal<T>()</p>
<p>会自动在每一个线程上创建一个T的副本，副本之间彼此独立，互不影响。</p>
<p>可以用 ThreadLocal存储一些参数，以便在线程中多个方法中使用，用来代替方法传参的做法。</p>
<blockquote>
<p>实在难以理解的，可以理解为，JVM维护了一个 Map&lt; Thread,T&gt;,每个线程要用这个T的时候，用当前的线程去Map里面取。仅作为一个概念理解</p>
</blockquote>
<p>代码示例:</p>
<pre><code class="language-java">/** 线程封闭示例 */
public class Demo5 {
	/** threadLocal变量，每个线程都有一个副本，互不干扰 */
	public static ThreadLocal&lt;String&gt; value = new ThreadLocal&lt;&gt;();

	/**
	 * threadlocal测试
	 * 
	 * @throws Exception
	 */
	public void threadLocalTest() throws Exception {

		// threadlocal线程封闭示例
		value.set(&quot;这是主线程设置的123&quot;); // 主线程设置值
		String v = value.get();
		System.out.println(&quot;线程1执行之前，主线程取到的值：&quot; + v);

		new Thread(new Runnable() {
			@Override
			public void run() {
				String v = value.get();
				System.out.println(&quot;线程1取到的值：&quot; + v);
				// 设置 threadLocal
				value.set(&quot;这是线程1设置的456&quot;);

				v = value.get();
				System.out.println(&quot;重新设置之后，线程1取到的值：&quot; + v);
				System.out.println(&quot;线程1执行结束&quot;);
			}
		}).start();

		Thread.sleep(5000L); // 等待所有线程执行结束

		v = value.get();
		System.out.println(&quot;线程1执行之后，主线程取到的值：&quot; + v);

	}

	public static void main(String[] args) throws Exception {
		new Demo5().threadLocalTest();
	}
}

</code></pre>
<p>运行结果:</p>
<blockquote>
<p>线程1执行之前，主线程取到的值：这是主线程设置的123<br>
线程1取到的值：null<br>
重新设置之后，线程1取到的值：这是线程1设置的456<br>
线程1执行结束<br>
线程1执行之后，主线程取到的值：这是主线程设置的123</p>
</blockquote>
<h2 id="栈封闭">栈封闭</h2>
<p><strong>局部变量</strong>的固有属性之一就是封闭在线程中.</p>
<p>它们位于执行线程的栈中,其他线程无法访问这个栈.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程通信]]></title>
        <id>https://www.sunjianbo.com/thread-communication/</id>
        <link href="https://www.sunjianbo.com/thread-communication/">
        </link>
        <updated>2020-08-07T04:13:43.000Z</updated>
        <content type="html"><![CDATA[<p>要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程执行的结果等等</p>
<p>涉及到线程之间相互通信，分为下面四类</p>
<h2 id="文件共享">文件共享</h2>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200612091611411.png" alt="" loading="lazy"></figure>
<h2 id="网络共享">网络共享</h2>
<p>略</p>
<h2 id="共享变量">共享变量</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200612091647383.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">  // 共享变量
  public static String content = &quot;空&quot;;
  
  public static void main(String[] args) {
    // 线程1 - 写入数据
    new Thread(() -&gt; {
      try {
        while (true) {
          content = &quot;当前时间&quot; + String.valueOf(System.currentTimeMillis());
          Thread.sleep(1000L);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();

    // 线程2 - 读取数据
    new Thread(() -&gt; {
      try {
        while (true) {
          Thread.sleep(1000L);
          System.out.println(content);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();
  }
</code></pre>
<h2 id="jdk提供的线程协调api">jdk提供的线程协调API</h2>
<p>JDK中对于需要多线程协作完成某一任务的场景，提供了对应API支持。</p>
<p>多线程协作的典型场景是：生产者-消费者模型(线程阻塞、线程唤醒)。</p>
<p>示例：线程1去买包子，没有包子，则不再执行。线程2生产出包子，通知线程-1继续执行。</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200612091856807.png" alt="" loading="lazy"></figure>
<h3 id="被弃用的suspend和resume">被弃用的suspend和resume</h3>
<p>作用:调用suspend挂起目标线程,通过resume可以恢复线程执行</p>
<h4 id="正常的suspendresume">正常的suspend/resume</h4>
<pre><code class="language-java">/** 包子店 */
public static Object baozidian = null;

/** 正常的suspend/resume */
public void suspendResumeTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="同步代码中使用导致死锁">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */
public void suspendResumeDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				Thread.currentThread().suspend();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		consumerThread.resume();
	}
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="resume比suspend先执行导致死锁">resume比suspend先执行导致死锁</h4>
<pre><code class="language-java">/** 导致程序永久挂起的suspend/resume */
public void suspendResumeDeadLockTest2() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) {
			System.out.println(&quot;1、没包子，进入等待&quot;);
			try { // 为这个线程加上一点延时
				Thread.sleep(5000L);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// 这里的挂起执行在resume后面
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
	consumerThread.join();
}
</code></pre>
<h3 id="waitnotify机制">wait/notify机制</h3>
<p>基于监视器实现,这些方法只能由<strong>同一对象锁的持有者线程</strong>调用，也就是写在同步块里面，否则会抛出IllegalMonitorStateException异常</p>
<p><strong>wait</strong>方法导致当前线程等待，其实就是将线程加入到对象的等待集合中，并且放弃当前持有的对象锁。</p>
<p><strong>notify/notifyall</strong>方法唤醒一个或所有正在等待这个对象锁的线程。</p>
<p><strong>注意：<strong>虽然会wait自动解锁，但是</strong>对顺序有要求</strong>，如果在 notify被调用之后，才开始wait方法的调用，线程会永远处于 WAITING状态。</p>
<h4 id="正常的waitnotify">正常的wait/notify</h4>
<pre><code class="language-java">/** 正常的wait/notify */
public void waitNotifyTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
			synchronized (this) {
				while (baozidian == null) { // 如果没包子，则进入等待
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h4 id="notify比wait先执行导致死锁">notify比wait先执行导致死锁</h4>
<pre><code class="language-java">/** 会导致程序永久等待的wait/notify */
public void waitNotifyDeadLockTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			try {
				Thread.sleep(5000L);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			synchronized (this) {
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h3 id="parkunpark机制">park/unpark机制</h3>
<p>线程调用park则等待&quot;许可(permit)&quot;.unpark方法为指定线程提供&quot;许可&quot;</p>
<p>不要求park和unpark方法的调用顺序</p>
<p>多次调用unpark后,再调用park,线程会直接运行,但<strong>许可不会叠加</strong>,</p>
<p>也就是说,连续多次调用park方法,第一次会拿到&quot;许可&quot;直接运行,后续调用依旧会进入等待.</p>
<h4 id="正常的parkunpark">正常的park/unpark</h4>
<pre><code class="language-java">/** 正常的park/unpark */
public void parkUnparkTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			LockSupport.park();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	LockSupport.unpark(consumerThread);
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h4 id="同步代码中使用导致死锁-2">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的park/unpark */
public void parkUnparkDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				LockSupport.park();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		LockSupport.unpark(consumerThread);
	}
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h3 id="伪唤醒">伪唤醒</h3>
<p><code>警告！之前代码中用if语句来判断，是否进入等待状态，是错误的！</code>(上文代码正常的都是使用的while)<br>
官方建议<code>应该在循环中检查等待条件</code>，原因是处于等待状态的线程可能会收到<code>错误警报和伪唤醒</code>，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>伪唤醒是指线程并非因为notify,notifyall,unpark等api调用而唤醒,是更底层原因导致的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CPU缓存和内存屏障]]></title>
        <id>https://www.sunjianbo.com/cpu-cache-and-memory-barrier/</id>
        <link href="https://www.sunjianbo.com/cpu-cache-and-memory-barrier/">
        </link>
        <updated>2020-08-06T03:40:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cpu缓存">CPU缓存</h2>
<p>为了提高程序运行的性能,现代CPU在很多方面对程序进行了优化.</p>
<p>例如:CPU高速缓存.尽可能地避免处理器访问主内存的时间开销,处理器大多会利用缓存(Cache)以提高性能.</p>
<h3 id="多级缓存">多级缓存</h3>
<h4 id="l1-cache一级缓存">L1 Cache(一级缓存)</h4>
<p>CPU第一层高速缓存,分为数据缓存和指令缓存.一般服务器CPU的L1缓存的容量在32---4096KB</p>
<h4 id="l2-cache">L2 Cache</h4>
<p>由于L1级高速缓存容量的限制,为了再次提高CPU的运算速度,在CPU外部放置一高速存储器,即二级缓存</p>
<h4 id="l3-cache">L3 Cache</h4>
<p>现在都是内置的,L3缓存的应用可以进一步降低内存延迟,同时提升大数据量计算时处理器的性能.具有较大L3缓存的处理器能提供更有效的文件系统缓存行为及较短消息和处理器队列长度.一般是多核共享一个L3缓存</p>
<p>CPU在读取数据时,先在L1中寻找,再从L2寻找,再从L3寻找,然后是内存,再后是外存储器(硬盘等)</p>
<h3 id="缓存同步协议">缓存同步协议</h3>
<p>多CPU读取同样的数据进行缓存,进行不同运算之后,最终写入主内存以哪个CPU为准?</p>
<p>在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。</p>
<p><strong>MESI协议</strong>，它规定每条缓存有个状态位，同时定义了下面四个状态:</p>
<ul>
<li>
<p>**修改态（ Modified）😗*此 cache行已被修改过（脏行），内容已不同于主存，为此 cache专有；</p>
</li>
<li>
<p>**专有态（ Exclusive）😗*此 cache行内容同于主存，但不出现于其它 cache中；</p>
</li>
<li>
<p>**共享态（ Shared）😗*此 cache行内容同于主存，但也出现于其它 cacher中；</p>
</li>
<li>
<p>**无效态（ Invalid）😗*此 cache？行内容无效（空行）。</p>
</li>
</ul>
<p>多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU.</p>
<p>也就是意味着，CPU处理要控制自己的读写操作，还要<strong>监听</strong>其他CPU发出的通知，从而保证<strong>最终一致</strong></p>
<h2 id="cpu指令重排">CPU指令重排</h2>
<h3 id="实例">实例</h3>
<pre><code class="language-java">//代码
x=100;
y=z;
</code></pre>
<p>正常执行的三步骤</p>
<blockquote>
<p>1、将100写入X<br>
2、读取z的值<br>
3、将z值写入y</p>
</blockquote>
<p>重排序后执行</p>
<blockquote>
<p>1、读取z的值<br>
2、将z值写入y<br>
3、将100写入X</p>
</blockquote>
<h3 id="指令重排的场景">指令重排的场景</h3>
<p>当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。</p>
<h3 id="as-if-serial">as-if- serial</h3>
<p>并非随便重排，需要遵守as-if- serial语义</p>
<p>as-if- serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p>编译器， runtime和处理器都必须遵守as-if- serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<h2 id="两个问题">两个问题</h2>
<h3 id="cpu高速缓存下的问题">CPU高速缓存下的问题</h3>
<p>缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。<strong>在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。</strong></p>
<h3 id="cpu执行指令重排序优化下的问题">CPU执行指令重排序优化下的问题</h3>
<p>虽然遵守了as- if-seriali语义，单仅在<strong>单CPU</strong>自己执行的情况下<strong>能保证结果正确</strong>。<br>
<strong>多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。</strong></p>
<h2 id="内存屏障">内存屏障</h2>
<p>为了解決上述两个问题,处理器提供了两个内存屏障指令（ Memory Barrier）</p>
<h3 id="写内存屏障-store-memory-barrier">写内存屏障（ Store Memory Barrier)</h3>
<p>在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>
<h3 id="读内存屏障-load-memory-barrier">读内存屏障（ Load Memory Barrier.)</h3>
<p>在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据。<br>
强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题</p>
<h2 id="结语">结语</h2>
<p>这个章节是后面<strong>JVM线程安全问题的铺垫</strong>。<br>
同时，也看到了现代CPU不断演进，在程序运行优化中做出的努力。不同CPU厂商所付出的人力物力成本，最终体现在不同CPU性能差距上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[clash for windows升级后发现socks端口合并到7890了]]></title>
        <id>https://www.sunjianbo.com/clash-for-windows-socks-port-7890/</id>
        <link href="https://www.sunjianbo.com/clash-for-windows-socks-port-7890/">
        </link>
        <updated>2020-07-24T01:19:11.000Z</updated>
        <content type="html"><![CDATA[<p>昨天手贱更新了一下订阅,结果不能用了,估计是规则进行了更新,没办法只好升级clash.</p>
<p>新版clash页面大改</p>
<p>升级完之后chrome怎么都上不去,后来仔细一看发现最新版0.11.1只写了一个端口7890</p>
<p>查看发布日志发现在0.10.2版本的时候将端口进行了合并</p>
<blockquote>
<p>migrate to mixed-port from port and socks-port</p>
</blockquote>
<p>虽说一个端口混合了http和socks用起来确实方便了,但是我这样的老用户还真是有点麻烦了,首先要改浏览器插件SwitchyOmega里面的端口,然后还要改Proxifier里面的端口.</p>
<p>关键是要是没注意到端口变化的人还真是要浪费很多的时间来排查问题.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程中止]]></title>
        <id>https://www.sunjianbo.com/thread-abort/</id>
        <link href="https://www.sunjianbo.com/thread-abort/">
        </link>
        <updated>2020-07-17T06:49:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="不推荐的中止方式">不推荐的中止方式</h2>
<h3 id="stop">stop</h3>
<blockquote>
<p>中止线程,并且清除监控器锁的信息,可能导致线程安全文件,jdk不建议使用</p>
</blockquote>
<p>举例说明如何导致线程安全问题:</p>
<p>先定义一个线程,实现i和j同时+1</p>
<pre><code class="language-java">public class StopThread extends Thread {
  private int i = 0, j = 0;

  @Override
  public void run() {
    synchronized (this) {
	    // 增加同步锁，确保线程安全
	    ++i;
	    try {
	      // 休眠10秒,模拟耗时操作
	      Thread.sleep(10000);
	    } catch (InterruptedException e) {
	      e.printStackTrace();
	    }
	    ++j;
    }
  }

  /** * 打印i和j */
  public void print() {
  System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
  }
}
</code></pre>
<p>stop方式中止</p>
<pre><code class="language-java">/**
 * 示例3 - 线程stop强制性中止，破坏线程安全的示例
 */
public class Demo31 {
  public static void main(String[] args) throws InterruptedException {
    StopThread thread = new StopThread();
    thread.start();
    // 休眠1秒，确保i变量自增成功
    Thread.sleep(1000);
    // 暂停线程
    thread.stop(); // 错误的终止
    // thread.interrupt(); // 正确终止
    while (thread.isAlive()) {
      // 确保线程已经终止
    } // 输出结果
    thread.print();
  }
}

</code></pre>
<p>理想输出:i=0 j=0</p>
<p>实际执行结果:i=1 j=0</p>
<p>i没有因中止而回滚,没有保证同步代码块里面的数据一致性,破坏了线程安全</p>
<h3 id="destroy">destroy</h3>
<blockquote>
<p>jdk未实现该方法</p>
</blockquote>
<h2 id="优雅的线程中止">优雅的线程中止</h2>
<h3 id="interrupt">interrupt</h3>
<ul>
<li>
<p>如果目标线程在调用Object class的<code>wait()</code>,<code>wait(long)</code>,<code>wait(long,int)</code>方法,<code>join()</code>,<code>join(long,int)</code>或<code>sleep(long,int)</code>方法时被阻塞,那么interrupt会生效,该线程的中断状态将被清除,抛出InterruptedException异常</p>
</li>
<li>
<p>如果目标线程是被I/O或者NIO中的Channel所阻塞,同样,I/O操作会被中断或者返回特殊异常值.达到终止线程的目的.</p>
</li>
<li>
<p>如果以上条件都不满足,则会设置此线程的中断状态.</p>
</li>
</ul>
<p>复用上面的例子,将其中的<code>thread.stop();</code>改为<code>thread.interrupt();</code>查看执行结果:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611104339183.png" alt="" loading="lazy"></figure>
<p>结果i=1 j=1保证了数据一致性,同时抛出一个InterruptedException异常来给开发者进行对应处理</p>
<h3 id="标志位">标志位</h3>
<p>代码逻辑中,增加一个判断,用来控制线程的中止.</p>
<p>如下示例,设置一个flag,通过外部修改flag的值来让while条件不满足跳出循环以使线程继续运行到结束:</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程状态]]></title>
        <id>https://www.sunjianbo.com/thread-state/</id>
        <link href="https://www.sunjianbo.com/thread-state/">
        </link>
        <updated>2020-07-03T01:47:48.000Z</updated>
        <content type="html"><![CDATA[<p>线程有6个状态,可以查看java.lang.Thread.State</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>New</td>
<td>尚未启动的线程的线程状态</td>
</tr>
<tr>
<td>Runnable</td>
<td>可运行线程的线程状态,等待CPU调度</td>
</tr>
<tr>
<td>Blocked</td>
<td>线程阻塞等待监视器锁定的线程状态</td>
</tr>
<tr>
<td>Waiting</td>
<td>等待线程的线程状态.下列不带超时的方式:<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.park</code></td>
</tr>
<tr>
<td>Timed Waiting</td>
<td>具有制定等待时间的等待线程的线程状态.下列带超时的方式:<code>Thread.sleep</code>,<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.parkNanos</code>,<code>LockSupport.parkUntil</code></td>
</tr>
<tr>
<td>Terminated</td>
<td>终止线程的线程状态,线程正常完成执行或者出现异常</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611094432936.png" alt="states" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 多线程运行状态切换示例 &lt;br/&gt;
 */
public class Demo2 {
	public static Thread thread1;
	public static Demo2 obj;

	public static void main(String[] args) throws Exception {
		// 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
		System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread1 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
		thread1.start();
		Thread.sleep(2000L); // 等待thread1执行结束，再看状态
		System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
		// thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

		System.out.println();
		System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {// 将线程2移动到等待状态，1500后自动唤醒
					Thread.sleep(1500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread2 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		thread2.start();
		System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(200L); // 等待200毫秒，再看状态
		System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
		System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

		System.out.println();
		System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (Demo2.class) {
					System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
					System.out.println(&quot;thread3 执行了&quot;);
				}
			}
		});
		synchronized (Demo2.class) {
			System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			thread3.start();
			System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			Thread.sleep(200L); // 等待200毫秒，再看状态
			System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
		}
		Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
		System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread2.getState().toString());

	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA程序运行原理分析]]></title>
        <id>https://www.sunjianbo.com/jvm-operation-principle/</id>
        <link href="https://www.sunjianbo.com/jvm-operation-principle/">
        </link>
        <updated>2020-07-02T03:08:07.000Z</updated>
        <content type="html"><![CDATA[<p>我的理解JVM内存结构就是程序由字节码文件读入到jvm中解析存储到执行所需要的一些东西</p>
<h2 id="class文件内容">class文件内容</h2>
<p>class文件包含JAVA程序执行的字节码;数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符;文件开头有一个0xcafebabe(16进制)特殊的一个标志.</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200610134740885.png" alt="class" loading="lazy"></figure>
<p>class文件内存储的是指令码</p>
<h2 id="jvm运行时数据区">JVM运行时数据区</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200610141943161.png" alt="jvm" loading="lazy"></figure>
<h3 id="线程共享">线程共享</h3>
<h4 id="方法区">方法区</h4>
<p>jvm用来存储加载的类信息,常量,静态变量,编译后的代码等数据.</p>
<p>这是虚拟机中的一个逻辑区划,具体实现根据不同虚拟机来实现.</p>
<p>如:oracle的HotSpot在java7中方法区放在永久代,java8放在元数据空间,并且通过GC机制对这个区域进行管理</p>
<h4 id="堆内存">堆内存</h4>
<p>堆内存是VM启动时创建,用于存放对象的实例.</p>
<p>还可以细分为:老年代,新生代(Eden,From Survivor,To Survivor).</p>
<p>垃圾回收器主要就是管理堆内存.</p>
<p>如果满了,就会出现OutOfMemoryError</p>
<h2 id="线程独享">线程独享</h2>
<h4 id="虚拟机栈">虚拟机栈</h4>
<p>每个线程都在这个空间又一个私有的空间.</p>
<p>线程栈由多个栈帧组成.</p>
<p>一个线程会执行一个或多个方法,一个方法对应一个栈帧.</p>
<p><strong>栈帧内容包含:局部变量表,操作数栈,动态链接,方法返回地址,附加信息等.</strong></p>
<p>栈内存默认最大是<strong>1M</strong>.超出则抛出StackOverFlowError</p>
<h4 id="本地方法栈">本地方法栈</h4>
<p>和虚拟机栈功能类似,不同的是虚拟机栈是为虚拟机执行java方法而准备的,本地方法栈是为虚拟机使用Native本地方法而准备的.</p>
<p>虚拟机规范没有规定具体的实现,由不同的虚拟机厂商去实现.</p>
<p>HotSpot虚拟机中的虚拟机栈和本地方法栈的实现是一样的.同样,超出大小以后也会抛出StackOverFlowError</p>
<h4 id="程序计数器program-counter-register">程序计数器(Program Counter Register)</h4>
<p>记录当前线程执行字节码的位置,存储的是字节码指令地址.</p>
<p>如果执行Native方法,则计数器值为空.</p>
<p>每个线程都在这个空间有一个私有的空间,占用内存空间很少.</p>
<p>CPU同一时间只会执行一条线程中的指令.JVM多线程会轮流切换并分配CPU执行时间.在线程切换后,需要通过程序计数器来恢复正确的执行位置.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[activemq启动报错Failed to connect to the Wrapper at port 32000]]></title>
        <id>https://www.sunjianbo.com/activemq-wrapper-error/</id>
        <link href="https://www.sunjianbo.com/activemq-wrapper-error/">
        </link>
        <updated>2020-05-06T08:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<blockquote>
<p>win7 x64</p>
<p>java1.8.0_20</p>
<p>activemq:5.15.12(当前最新)</p>
</blockquote>
<h2 id="报错信息">报错信息</h2>
<p>运行<code>apache-activemq\bin\win64\activemq.bat</code>报如下错误:</p>
<pre><code>jvm 1    | Failed to connect to the Wrapper at port 32000.
jvm 1    | java.net.ConnectException: connect: Address is invalid on local machine, or port is not valid on remote machine
jvm 1    | Exiting JVM...
</code></pre>
<p>编辑<code>win64</code>目录下<code>wrapper.conf</code>文件,取消注释</p>
<pre><code># wrapper.debug=TRUE
</code></pre>
<hr>
<p>title: 'activemq启动报错Failed to connect to the Wrapper at port 32000'<br>
date: 2020-05-06 16:36:28<br>
tags: [activemq,wrapper,报错]<br>
published: true<br>
hideInList: false<br>
feature:<br>
isTop: false</p>
<hr>
<pre><code>INFO   | jvm 1    | 2020/05/06 16:26:52 | Load native library.  One or more attempts may fail if platform specific libraries do not exist.
INFO   | jvm 1    | 2020/05/06 16:26:52 | Loading native library failed: wrapper-windows-x86-64.dll  Cause: java.lang.UnsatisfiedLinkError: no wrapper-windows-x86-64 in java.library.path
</code></pre>
<h2 id="试图解决">试图解决</h2>
<p>根据以上两个关键信息进行Google,然而崩溃的是股沟了好久没有找到解决方法</p>
<p>期间尝试了网上说的修改<code>conf/activemq.xml</code>与<code>conf/jetty.xml</code>配置文件中的ip<code>0.0.0.0</code>改为<code>127.0.0.1</code></p>
<p>修改<code>wrapper.conf</code>文件中的<code>wrapper.java.command=java</code>为指定<code>jdkpath\bin\java</code></p>
<p>均无效,最后放弃这种启动方式,改为下面方式启动.没有报错</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>双击运行<code>apache-activemq\bin\win6\InstallService.bat</code>以安装服务</p>
<p><code>win+r</code>启动<code>cmd</code>输入:</p>
<pre><code>net start activemq
</code></pre>
<p>完全没报错,顺利启动</p>
<p>浏览器打开<a href="http://127.0.0.1:8161">http://127.0.0.1:8161</a></p>
<p>成功访问</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hp chromebook 11 G1通过crouton安装及使用Debian]]></title>
        <id>https://www.sunjianbo.com/chromebook-crouton-linux/</id>
        <link href="https://www.sunjianbo.com/chromebook-crouton-linux/">
        </link>
        <updated>2020-04-24T06:31:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一关于备份">一.关于备份</h2>
<p>在操作之前本来应该是备份的,但是考虑到官方提供救砖的方法(<a href="https://support.google.com/chromebook/answer/1080595?hl=zh-Hans">https://support.google.com/chromebook/answer/1080595?hl=zh-Hans</a>),也就先放心的直接上手安装了.(主要原因其实是没有u盘(◔◡◔))</p>
<h2 id="二进入开发者模式">二.进入开发者模式</h2>
<p>同时按住<code>esc + refresh + power</code></p>
<p>然后自动重启,提示你系统已经损坏,好了结束了,可以卖破烂了(◔◡◔)</p>
<p>当然不会这样,再按一下<code>ctrl+D</code>提示关闭系统验证,再按Enter,提示验证已关闭,继续<code>ctrl+D</code>*2</p>
<p>最后系统开始为了进入开发者模式准备一些东西,需要等待几分钟.</p>
<p>准备完成重启之后,就始终需要按<code>ctrl+D</code>来进入chromeOS了</p>
<h2 id="三下载crouton">三.下载crouton</h2>
<p>crouton项目的github:<a href="https://github.com/dnschneid/crouton">https://github.com/dnschneid/crouton</a></p>
<p>在Usage内容下有个下载地址,这里直接贴出来了:<a href="https://goo.gl/fd3zc">https://goo.gl/fd3zc</a></p>
<p>下载下来应该默认存储在</p>
<h2 id="四打开shell">四.打开shell</h2>
<p><code>ctrl+alt+t</code>打开一个命令行,这是chrome的crosh,再输入<code>shell</code>回车进入linux shell</p>
<h2 id="五安装linux">五.安装linux</h2>
<p>因为配置垃圾,所以选择了debian buster+lxde桌面,在这之前我查看了一下剩余空间<strong>9.2G</strong></p>
<pre><code class="language-shell">sudo sh crouton -r buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<p><code>-P</code> 参数是用来指定翻墙代理的,下面命令可以查看所有可安装的linux</p>
<pre><code class="language-shell">sudo sh crouton -t list -P http://127.0.0.1:7890
</code></pre>
<h3 id="中间因为网络问题失败了一次再次安装会报错">中间因为网络问题失败了一次,再次安装会报错:</h3>
<blockquote>
<p>/usr/local/chroots/buster already has stuff in it!<br>
Either delete it, specify a different name (-n), or specify -u to update it.</p>
</blockquote>
<p>根据提示使用以下命令才能继续</p>
<pre><code>sudo sh crouton -u -n buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<h3 id="安装耗时1410-1701接近三小时公司垃圾网下载速度不到100下载文件500m左右安装完成后第一次启动后剩余空间76g即占用16g">安装耗时14.10-17.01接近三小时,公司垃圾网下载速度不到100,下载文件500M左右,安装完成后第一次启动后剩余空间7.6G,即占用1.6G</h3>
<h3 id="启动linux">启动linux</h3>
<pre><code>sudo startlxde
</code></pre>
<h2 id="六备份回复删除系">六.备份/回复/删除系</h2>
<p>备份命令:</p>
<pre><code>sudo edit-chroot -b buster -f ~/Downloads/buster-backup.bak
</code></pre>
<p>恢复:</p>
<pre><code>sudo sh -e ~/Downloads/crouton -f ~/Downloads/buster-backup.bak
</code></pre>
<p>删除</p>
<pre><code>sudo delete-chroot buster
</code></pre>
<p>或者</p>
<pre><code>sudo edit-chroot -d buster
</code></pre>
<h2 id="七使用">七.使用:</h2>
<h3 id="1不启动整个linux只启动其shell">1.不启动整个linux只启动其shell:</h3>
<pre><code>sudo enter-chroot
</code></pre>
<h3 id="2系统任意切换">2.系统任意切换</h3>
<blockquote>
<p>shift+ctrl+alt+前进键(F2)/后退键(F1)</p>
</blockquote>
<p>不是说后退切换过去然后前进切换回来,而是只要用一个组合键就可以来回切换,按一下切换再按一下切换回来</p>
<h3 id="3安装后系统配置">3.安装后系统配置</h3>
<p>参考这篇文章:<a href="https://frapples.github.io/articles/2017-05-11-e6dc.html">https://frapples.github.io/articles/2017-05-11-e6dc.html</a></p>
<h3 id="4安装clash">4.安装clash</h3>
<p>chrome的shadowsocks插件比较老,很多新的加密协议都不支持,所以我之前都是走局域网的代理,装好clash就可以自给自足了</p>
<p>完整教程:<a href="https://ssu.tw/index.php/archives/37/">https://ssu.tw/index.php/archives/37/</a></p>
<pre><code>cd ~
sudo mkdir clash //创建目录
cd clash //切换至此目录
sudo wget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-armv7-v0.19.0.gz //下载D大预编译好的包
sudo gunzip clash-linux-armv7-v0.19.0.gz //解压，记得可以使用Tab键补全，得到clash的二进制
sudo mv clash-linux-armv7-v0.19.0 /usr/local/bin/clash //移动并重命名，简短方便使用
sudo chmod +x /usr/local/bin/clash //赋予此文件可执行权限
</code></pre>
<p>下载配置文件样例</p>
<pre><code>sudo wget https://raw.githubusercontent.com/ConnersHua/Profiles/master/Clash/Pro.yaml //下载范例配置文件
sudo mv Pro.yaml config.yaml //重命名
</code></pre>
<p>修改配置文件</p>
<pre><code>sudo vim config.yaml //编辑此配置文件

# 这里建议从false改为true，允许局域网共享
allow-lan: true

# 下面这行，建议取消前面#注释符号
bind-address: &quot;*&quot;

# RESTful API for clash
# 修改外部控制，将127.0.0.1改为0.0.0.0
external-controller: 0.0.0.0:9090
</code></pre>
<p>启动clash</p>
<pre><code>clash -d ~/clash
</code></pre>
<p>clash启动之后，你可以用局域网的设备访问<code>http://clash.razord.top</code>， 然后Host填写你树莓派在局域网中的IP地址，端口填写上面设置的9090，即可访问成功。</p>
<h3 id="5安装typora失败">5.安装Typora(失败)</h3>
<p>因为本来搞个chromebook定位就是用来写文档的,所以安装自己用习惯的md编辑器Typora,方法参考<a href="https://support.typora.io/Typora-on-Linux/">官方文档</a></p>
<pre><code class="language-shell">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -
sudo add-apt-repository 'deb https://typora.io/linux ./'
# 若报错 add-apt-repository: command not found则先执行:sudo apt-get install software-properties-common
sudo apt-get update
sudo apt-get install typora
</code></pre>
]]></content>
    </entry>
</feed>