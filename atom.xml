<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-08-06T04:39:05.982Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[CPU缓存和内存屏障]]></title>
        <id>https://www.sunjianbo.com/cpu-cache-and-memory-barrier/</id>
        <link href="https://www.sunjianbo.com/cpu-cache-and-memory-barrier/">
        </link>
        <updated>2020-08-06T03:40:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cpu缓存">CPU缓存</h2>
<p>为了提高程序运行的性能,现代CPU在很多方面对程序进行了优化.</p>
<p>例如:CPU高速缓存.尽可能地避免处理器访问主内存的时间开销,处理器大多会利用缓存(Cache)以提高性能.</p>
<h3 id="多级缓存">多级缓存</h3>
<h4 id="l1-cache一级缓存">L1 Cache(一级缓存)</h4>
<p>CPU第一层高速缓存,分为数据缓存和指令缓存.一般服务器CPU的L1缓存的容量在32---4096KB</p>
<h4 id="l2-cache">L2 Cache</h4>
<p>由于L1级高速缓存容量的限制,为了再次提高CPU的运算速度,在CPU外部放置一高速存储器,即二级缓存</p>
<h4 id="l3-cache">L3 Cache</h4>
<p>现在都是内置的,L3缓存的应用可以进一步降低内存延迟,同时提升大数据量计算时处理器的性能.具有较大L3缓存的处理器能提供更有效的文件系统缓存行为及较短消息和处理器队列长度.一般是多核共享一个L3缓存</p>
<p>CPU在读取数据时,先在L1中寻找,再从L2寻找,再从L3寻找,然后是内存,再后是外存储器(硬盘等)</p>
<h3 id="缓存同步协议">缓存同步协议</h3>
<p>多CPU读取同样的数据进行缓存,进行不同运算之后,最终写入主内存以哪个CPU为准?</p>
<p>在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。</p>
<p><strong>MESI协议</strong>，它规定每条缓存有个状态位，同时定义了下面四个状态:</p>
<ul>
<li>
<p>**修改态（ Modified）😗*此 cache行已被修改过（脏行），内容已不同于主存，为此 cache专有；</p>
</li>
<li>
<p>**专有态（ Exclusive）😗*此 cache行内容同于主存，但不出现于其它 cache中；</p>
</li>
<li>
<p>**共享态（ Shared）😗*此 cache行内容同于主存，但也出现于其它 cacher中；</p>
</li>
<li>
<p>**无效态（ Invalid）😗*此 cache？行内容无效（空行）。</p>
</li>
</ul>
<p>多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU.</p>
<p>也就是意味着，CPU处理要控制自己的读写操作，还要<strong>监听</strong>其他CPU发出的通知，从而保证<strong>最终一致</strong></p>
<h2 id="cpu指令重排">CPU指令重排</h2>
<h3 id="实例">实例</h3>
<pre><code class="language-java">//代码
x=100;
y=z;
</code></pre>
<p>正常执行的三步骤</p>
<blockquote>
<p>1、将100写入X<br>
2、读取z的值<br>
3、将z值写入y</p>
</blockquote>
<p>重排序后执行</p>
<blockquote>
<p>1、读取z的值<br>
2、将z值写入y<br>
3、将100写入X</p>
</blockquote>
<h3 id="指令重排的场景">指令重排的场景</h3>
<p>当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。</p>
<h3 id="as-if-serial">as-if- serial</h3>
<p>并非随便重排，需要遵守as-if- serial语义</p>
<p>as-if- serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p>编译器， runtime和处理器都必须遵守as-if- serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<h2 id="两个问题">两个问题</h2>
<h3 id="cpu高速缓存下的问题">CPU高速缓存下的问题</h3>
<p>缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。<strong>在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。</strong></p>
<h3 id="cpu执行指令重排序优化下的问题">CPU执行指令重排序优化下的问题</h3>
<p>虽然遵守了as- if-seriali语义，单仅在<strong>单CPU</strong>自己执行的情况下<strong>能保证结果正确</strong>。<br>
<strong>多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。</strong></p>
<h2 id="内存屏障">内存屏障</h2>
<p>为了解決上述两个问题,处理器提供了两个内存屏障指令（ Memory Barrier）</p>
<h3 id="写内存屏障-store-memory-barrier">写内存屏障（ Store Memory Barrier)</h3>
<p>在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>
<h3 id="读内存屏障-load-memory-barrier">读内存屏障（ Load Memory Barrier.)</h3>
<p>在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据。<br>
强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题</p>
<h2 id="结语">结语</h2>
<p>这个章节是后面<strong>JVM线程安全问题的铺垫</strong>。<br>
同时，也看到了现代CPU不断演进，在程序运行优化中做出的努力。不同CPU厂商所付出的人力物力成本，最终体现在不同CPU性能差距上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[clash for windows升级后发现socks端口合并到7890了]]></title>
        <id>https://www.sunjianbo.com/clash-for-windows-socks-port-7890/</id>
        <link href="https://www.sunjianbo.com/clash-for-windows-socks-port-7890/">
        </link>
        <updated>2020-07-24T01:19:11.000Z</updated>
        <content type="html"><![CDATA[<p>昨天手贱更新了一下订阅,结果不能用了,估计是规则进行了更新,没办法只好升级clash.</p>
<p>新版clash页面大改</p>
<p>升级完之后chrome怎么都上不去,后来仔细一看发现最新版0.11.1只写了一个端口7890</p>
<p>查看发布日志发现在0.10.2版本的时候将端口进行了合并</p>
<blockquote>
<p>migrate to mixed-port from port and socks-port</p>
</blockquote>
<p>虽说一个端口混合了http和socks用起来确实方便了,但是我这样的老用户还真是有点麻烦了,首先要改浏览器插件SwitchyOmega里面的端口,然后还要改Proxifier里面的端口.</p>
<p>关键是要是没注意到端口变化的人还真是要浪费很多的时间来排查问题.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程中止]]></title>
        <id>https://www.sunjianbo.com/thread-abort/</id>
        <link href="https://www.sunjianbo.com/thread-abort/">
        </link>
        <updated>2020-07-17T06:49:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="不推荐的中止方式">不推荐的中止方式</h2>
<h3 id="stop">stop</h3>
<blockquote>
<p>中止线程,并且清除监控器锁的信息,可能导致线程安全文件,jdk不建议使用</p>
</blockquote>
<p>举例说明如何导致线程安全问题:</p>
<p>先定义一个线程,实现i和j同时+1</p>
<pre><code class="language-java">public class StopThread extends Thread {
  private int i = 0, j = 0;

  @Override
  public void run() {
    synchronized (this) {
	    // 增加同步锁，确保线程安全
	    ++i;
	    try {
	      // 休眠10秒,模拟耗时操作
	      Thread.sleep(10000);
	    } catch (InterruptedException e) {
	      e.printStackTrace();
	    }
	    ++j;
    }
  }

  /** * 打印i和j */
  public void print() {
  System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
  }
}
</code></pre>
<p>stop方式中止</p>
<pre><code class="language-java">/**
 * 示例3 - 线程stop强制性中止，破坏线程安全的示例
 */
public class Demo31 {
  public static void main(String[] args) throws InterruptedException {
    StopThread thread = new StopThread();
    thread.start();
    // 休眠1秒，确保i变量自增成功
    Thread.sleep(1000);
    // 暂停线程
    thread.stop(); // 错误的终止
    // thread.interrupt(); // 正确终止
    while (thread.isAlive()) {
      // 确保线程已经终止
    } // 输出结果
    thread.print();
  }
}

</code></pre>
<p>理想输出:i=0 j=0</p>
<p>实际执行结果:i=1 j=0</p>
<p>i没有因中止而回滚,没有保证同步代码块里面的数据一致性,破坏了线程安全</p>
<h3 id="destroy">destroy</h3>
<blockquote>
<p>jdk未实现该方法</p>
</blockquote>
<h2 id="优雅的线程中止">优雅的线程中止</h2>
<h3 id="interrupt">interrupt</h3>
<ul>
<li>
<p>如果目标线程在调用Object class的<code>wait()</code>,<code>wait(long)</code>,<code>wait(long,int)</code>方法,<code>join()</code>,<code>join(long,int)</code>或<code>sleep(long,int)</code>方法时被阻塞,那么interrupt会生效,该线程的中断状态将被清除,抛出InterruptedException异常</p>
</li>
<li>
<p>如果目标线程是被I/O或者NIO中的Channel所阻塞,同样,I/O操作会被中断或者返回特殊异常值.达到终止线程的目的.</p>
</li>
<li>
<p>如果以上条件都不满足,则会设置此线程的中断状态.</p>
</li>
</ul>
<p>复用上面的例子,将其中的<code>thread.stop();</code>改为<code>thread.interrupt();</code>查看执行结果:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611104339183.png" alt="" loading="lazy"></figure>
<p>结果i=1 j=1保证了数据一致性,同时抛出一个InterruptedException异常来给开发者进行对应处理</p>
<h3 id="标志位">标志位</h3>
<p>代码逻辑中,增加一个判断,用来控制线程的中止.</p>
<p>如下示例,设置一个flag,通过外部修改flag的值来让while条件不满足跳出循环以使线程继续运行到结束:</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程状态]]></title>
        <id>https://www.sunjianbo.com/thread-state/</id>
        <link href="https://www.sunjianbo.com/thread-state/">
        </link>
        <updated>2020-07-03T01:47:48.000Z</updated>
        <content type="html"><![CDATA[<p>线程有6个状态,可以查看java.lang.Thread.State</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>New</td>
<td>尚未启动的线程的线程状态</td>
</tr>
<tr>
<td>Runnable</td>
<td>可运行线程的线程状态,等待CPU调度</td>
</tr>
<tr>
<td>Blocked</td>
<td>线程阻塞等待监视器锁定的线程状态</td>
</tr>
<tr>
<td>Waiting</td>
<td>等待线程的线程状态.下列不带超时的方式:<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.park</code></td>
</tr>
<tr>
<td>Timed Waiting</td>
<td>具有制定等待时间的等待线程的线程状态.下列带超时的方式:<code>Thread.sleep</code>,<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.parkNanos</code>,<code>LockSupport.parkUntil</code></td>
</tr>
<tr>
<td>Terminated</td>
<td>终止线程的线程状态,线程正常完成执行或者出现异常</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611094432936.png" alt="states" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 多线程运行状态切换示例 &lt;br/&gt;
 */
public class Demo2 {
	public static Thread thread1;
	public static Demo2 obj;

	public static void main(String[] args) throws Exception {
		// 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
		System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread1 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
		thread1.start();
		Thread.sleep(2000L); // 等待thread1执行结束，再看状态
		System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
		// thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

		System.out.println();
		System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {// 将线程2移动到等待状态，1500后自动唤醒
					Thread.sleep(1500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread2 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		thread2.start();
		System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(200L); // 等待200毫秒，再看状态
		System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
		System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

		System.out.println();
		System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (Demo2.class) {
					System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
					System.out.println(&quot;thread3 执行了&quot;);
				}
			}
		});
		synchronized (Demo2.class) {
			System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			thread3.start();
			System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			Thread.sleep(200L); // 等待200毫秒，再看状态
			System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
		}
		Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
		System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread2.getState().toString());

	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA程序运行原理分析]]></title>
        <id>https://www.sunjianbo.com/jvm-operation-principle/</id>
        <link href="https://www.sunjianbo.com/jvm-operation-principle/">
        </link>
        <updated>2020-07-02T03:08:07.000Z</updated>
        <content type="html"><![CDATA[<p>我的理解JVM内存结构就是程序由字节码文件读入到jvm中解析存储到执行所需要的一些东西</p>
<h2 id="class文件内容">class文件内容</h2>
<p>class文件包含JAVA程序执行的字节码;数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符;文件开头有一个0xcafebabe(16进制)特殊的一个标志.</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200610134740885.png" alt="class" loading="lazy"></figure>
<p>class文件内存储的是指令码</p>
<h2 id="jvm运行时数据区">JVM运行时数据区</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200610141943161.png" alt="jvm" loading="lazy"></figure>
<h3 id="线程共享">线程共享</h3>
<h4 id="方法区">方法区</h4>
<p>jvm用来存储加载的类信息,常量,静态变量,编译后的代码等数据.</p>
<p>这是虚拟机中的一个逻辑区划,具体实现根据不同虚拟机来实现.</p>
<p>如:oracle的HotSpot在java7中方法区放在永久代,java8放在元数据空间,并且通过GC机制对这个区域进行管理</p>
<h4 id="堆内存">堆内存</h4>
<p>堆内存是VM启动时创建,用于存放对象的实例.</p>
<p>还可以细分为:老年代,新生代(Eden,From Survivor,To Survivor).</p>
<p>垃圾回收器主要就是管理堆内存.</p>
<p>如果满了,就会出现OutOfMemoryError</p>
<h2 id="线程独享">线程独享</h2>
<h4 id="虚拟机栈">虚拟机栈</h4>
<p>每个线程都在这个空间又一个私有的空间.</p>
<p>线程栈由多个栈帧组成.</p>
<p>一个线程会执行一个或多个方法,一个方法对应一个栈帧.</p>
<p><strong>栈帧内容包含:局部变量表,操作数栈,动态链接,方法返回地址,附加信息等.</strong></p>
<p>栈内存默认最大是<strong>1M</strong>.超出则抛出StackOverFlowError</p>
<h4 id="本地方法栈">本地方法栈</h4>
<p>和虚拟机栈功能类似,不同的是虚拟机栈是为虚拟机执行java方法而准备的,本地方法栈是为虚拟机使用Native本地方法而准备的.</p>
<p>虚拟机规范没有规定具体的实现,由不同的虚拟机厂商去实现.</p>
<p>HotSpot虚拟机中的虚拟机栈和本地方法栈的实现是一样的.同样,超出大小以后也会抛出StackOverFlowError</p>
<h4 id="程序计数器program-counter-register">程序计数器(Program Counter Register)</h4>
<p>记录当前线程执行字节码的位置,存储的是字节码指令地址.</p>
<p>如果执行Native方法,则计数器值为空.</p>
<p>每个线程都在这个空间有一个私有的空间,占用内存空间很少.</p>
<p>CPU同一时间只会执行一条线程中的指令.JVM多线程会轮流切换并分配CPU执行时间.在线程切换后,需要通过程序计数器来恢复正确的执行位置.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[activemq启动报错Failed to connect to the Wrapper at port 32000]]></title>
        <id>https://www.sunjianbo.com/activemq-wrapper-error/</id>
        <link href="https://www.sunjianbo.com/activemq-wrapper-error/">
        </link>
        <updated>2020-05-06T08:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<blockquote>
<p>win7 x64</p>
<p>java1.8.0_20</p>
<p>activemq:5.15.12(当前最新)</p>
</blockquote>
<h2 id="报错信息">报错信息</h2>
<p>运行<code>apache-activemq\bin\win64\activemq.bat</code>报如下错误:</p>
<pre><code>jvm 1    | Failed to connect to the Wrapper at port 32000.
jvm 1    | java.net.ConnectException: connect: Address is invalid on local machine, or port is not valid on remote machine
jvm 1    | Exiting JVM...
</code></pre>
<p>编辑<code>win64</code>目录下<code>wrapper.conf</code>文件,取消注释</p>
<pre><code># wrapper.debug=TRUE
</code></pre>
<hr>
<p>title: 'activemq启动报错Failed to connect to the Wrapper at port 32000'<br>
date: 2020-05-06 16:36:28<br>
tags: [activemq,wrapper,报错]<br>
published: true<br>
hideInList: false<br>
feature:<br>
isTop: false</p>
<hr>
<pre><code>INFO   | jvm 1    | 2020/05/06 16:26:52 | Load native library.  One or more attempts may fail if platform specific libraries do not exist.
INFO   | jvm 1    | 2020/05/06 16:26:52 | Loading native library failed: wrapper-windows-x86-64.dll  Cause: java.lang.UnsatisfiedLinkError: no wrapper-windows-x86-64 in java.library.path
</code></pre>
<h2 id="试图解决">试图解决</h2>
<p>根据以上两个关键信息进行Google,然而崩溃的是股沟了好久没有找到解决方法</p>
<p>期间尝试了网上说的修改<code>conf/activemq.xml</code>与<code>conf/jetty.xml</code>配置文件中的ip<code>0.0.0.0</code>改为<code>127.0.0.1</code></p>
<p>修改<code>wrapper.conf</code>文件中的<code>wrapper.java.command=java</code>为指定<code>jdkpath\bin\java</code></p>
<p>均无效,最后放弃这种启动方式,改为下面方式启动.没有报错</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>双击运行<code>apache-activemq\bin\win6\InstallService.bat</code>以安装服务</p>
<p><code>win+r</code>启动<code>cmd</code>输入:</p>
<pre><code>net start activemq
</code></pre>
<p>完全没报错,顺利启动</p>
<p>浏览器打开<a href="http://127.0.0.1:8161">http://127.0.0.1:8161</a></p>
<p>成功访问</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hp chromebook 11 G1通过crouton安装及使用Debian]]></title>
        <id>https://www.sunjianbo.com/chromebook-crouton-linux/</id>
        <link href="https://www.sunjianbo.com/chromebook-crouton-linux/">
        </link>
        <updated>2020-04-24T06:31:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一关于备份">一.关于备份</h2>
<p>在操作之前本来应该是备份的,但是考虑到官方提供救砖的方法(<a href="https://support.google.com/chromebook/answer/1080595?hl=zh-Hans">https://support.google.com/chromebook/answer/1080595?hl=zh-Hans</a>),也就先放心的直接上手安装了.(主要原因其实是没有u盘(◔◡◔))</p>
<h2 id="二进入开发者模式">二.进入开发者模式</h2>
<p>同时按住<code>esc + refresh + power</code></p>
<p>然后自动重启,提示你系统已经损坏,好了结束了,可以卖破烂了(◔◡◔)</p>
<p>当然不会这样,再按一下<code>ctrl+D</code>提示关闭系统验证,再按Enter,提示验证已关闭,继续<code>ctrl+D</code>*2</p>
<p>最后系统开始为了进入开发者模式准备一些东西,需要等待几分钟.</p>
<p>准备完成重启之后,就始终需要按<code>ctrl+D</code>来进入chromeOS了</p>
<h2 id="三下载crouton">三.下载crouton</h2>
<p>crouton项目的github:<a href="https://github.com/dnschneid/crouton">https://github.com/dnschneid/crouton</a></p>
<p>在Usage内容下有个下载地址,这里直接贴出来了:<a href="https://goo.gl/fd3zc">https://goo.gl/fd3zc</a></p>
<p>下载下来应该默认存储在</p>
<h2 id="四打开shell">四.打开shell</h2>
<p><code>ctrl+alt+t</code>打开一个命令行,这是chrome的crosh,再输入<code>shell</code>回车进入linux shell</p>
<h2 id="五安装linux">五.安装linux</h2>
<p>因为配置垃圾,所以选择了debian buster+lxde桌面,在这之前我查看了一下剩余空间<strong>9.2G</strong></p>
<pre><code class="language-shell">sudo sh crouton -r buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<p><code>-P</code> 参数是用来指定翻墙代理的,下面命令可以查看所有可安装的linux</p>
<pre><code class="language-shell">sudo sh crouton -t list -P http://127.0.0.1:7890
</code></pre>
<h3 id="中间因为网络问题失败了一次再次安装会报错">中间因为网络问题失败了一次,再次安装会报错:</h3>
<blockquote>
<p>/usr/local/chroots/buster already has stuff in it!<br>
Either delete it, specify a different name (-n), or specify -u to update it.</p>
</blockquote>
<p>根据提示使用以下命令才能继续</p>
<pre><code>sudo sh crouton -u -n buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<h3 id="安装耗时1410-1701接近三小时公司垃圾网下载速度不到100下载文件500m左右安装完成后第一次启动后剩余空间76g即占用16g">安装耗时14.10-17.01接近三小时,公司垃圾网下载速度不到100,下载文件500M左右,安装完成后第一次启动后剩余空间7.6G,即占用1.6G</h3>
<h3 id="启动linux">启动linux</h3>
<pre><code>sudo startlxde
</code></pre>
<h2 id="六备份回复删除系">六.备份/回复/删除系</h2>
<p>备份命令:</p>
<pre><code>sudo edit-chroot -b buster -f ~/Downloads/buster-backup.bak
</code></pre>
<p>恢复:</p>
<pre><code>sudo sh -e ~/Downloads/crouton -f ~/Downloads/buster-backup.bak
</code></pre>
<p>删除</p>
<pre><code>sudo delete-chroot buster
</code></pre>
<p>或者</p>
<pre><code>sudo edit-chroot -d buster
</code></pre>
<h2 id="七使用">七.使用:</h2>
<h3 id="1不启动整个linux只启动其shell">1.不启动整个linux只启动其shell:</h3>
<pre><code>sudo enter-chroot
</code></pre>
<h3 id="2系统任意切换">2.系统任意切换</h3>
<blockquote>
<p>shift+ctrl+alt+前进键(F2)/后退键(F1)</p>
</blockquote>
<p>不是说后退切换过去然后前进切换回来,而是只要用一个组合键就可以来回切换,按一下切换再按一下切换回来</p>
<h3 id="3安装后系统配置">3.安装后系统配置</h3>
<p>参考这篇文章:<a href="https://frapples.github.io/articles/2017-05-11-e6dc.html">https://frapples.github.io/articles/2017-05-11-e6dc.html</a></p>
<h3 id="4安装clash">4.安装clash</h3>
<p>chrome的shadowsocks插件比较老,很多新的加密协议都不支持,所以我之前都是走局域网的代理,装好clash就可以自给自足了</p>
<p>完整教程:<a href="https://ssu.tw/index.php/archives/37/">https://ssu.tw/index.php/archives/37/</a></p>
<pre><code>cd ~
sudo mkdir clash //创建目录
cd clash //切换至此目录
sudo wget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-armv7-v0.19.0.gz //下载D大预编译好的包
sudo gunzip clash-linux-armv7-v0.19.0.gz //解压，记得可以使用Tab键补全，得到clash的二进制
sudo mv clash-linux-armv7-v0.19.0 /usr/local/bin/clash //移动并重命名，简短方便使用
sudo chmod +x /usr/local/bin/clash //赋予此文件可执行权限
</code></pre>
<p>下载配置文件样例</p>
<pre><code>sudo wget https://raw.githubusercontent.com/ConnersHua/Profiles/master/Clash/Pro.yaml //下载范例配置文件
sudo mv Pro.yaml config.yaml //重命名
</code></pre>
<p>修改配置文件</p>
<pre><code>sudo vim config.yaml //编辑此配置文件

# 这里建议从false改为true，允许局域网共享
allow-lan: true

# 下面这行，建议取消前面#注释符号
bind-address: &quot;*&quot;

# RESTful API for clash
# 修改外部控制，将127.0.0.1改为0.0.0.0
external-controller: 0.0.0.0:9090
</code></pre>
<p>启动clash</p>
<pre><code>clash -d ~/clash
</code></pre>
<p>clash启动之后，你可以用局域网的设备访问<code>http://clash.razord.top</code>， 然后Host填写你树莓派在局域网中的IP地址，端口填写上面设置的9090，即可访问成功。</p>
<h3 id="5安装typora失败">5.安装Typora(失败)</h3>
<p>因为本来搞个chromebook定位就是用来写文档的,所以安装自己用习惯的md编辑器Typora,方法参考<a href="https://support.typora.io/Typora-on-Linux/">官方文档</a></p>
<pre><code class="language-shell">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -
sudo add-apt-repository 'deb https://typora.io/linux ./'
# 若报错 add-apt-repository: command not found则先执行:sudo apt-get install software-properties-common
sudo apt-get update
sudo apt-get install typora
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git push error dst refspec "XXX" matches more than one]]></title>
        <id>https://www.sunjianbo.com/git-push-matches-more-than-one/</id>
        <link href="https://www.sunjianbo.com/git-push-matches-more-than-one/">
        </link>
        <updated>2020-04-15T04:36:08.000Z</updated>
        <content type="html"><![CDATA[<p>今天在2.1.2分支上修改完xxl-job的数据库为oracle之后想要提交,结果报错</p>
<h3 id="报错信息">报错信息</h3>
<blockquote>
<p>Failed with error: HttpRequestException encountered. dst refspec 2.1.2 matches more than one. failed to push some refs to 'https://github.com/sunjianbo/xxl-job.git'</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/1586921186771_17.png" alt="error" loading="lazy"></figure>
<h3 id="原因">原因</h3>
<p>翻译一下就是你想要提交到的目标不只存在一个,git不知道你要提交到哪一个了<br>
那么分支名称肯定是不会出现重复的,那就只可能是分支名和tag名冲突了</p>
<pre><code>$ git tag
</code></pre>
<p>查看发现果然也存在一个叫做2.1.2的tag</p>
<h3 id="解决方案">解决方案</h3>
<p>删除本地标签</p>
<pre><code>$ git tag -d 2.1.2
</code></pre>
<p>删除远程标签</p>
<pre><code>$ git push origin :refs/tags/2.1.2
</code></pre>
<p>顺利提交<br>
<img src="https://static.sunjianbo.com/1586921495457_18.png" alt="pushed" loading="lazy"></p>
<p>附git tag常用操作速查:</p>
<p><a href="https://blog.csdn.net/happycxz/article/details/78893690">https://blog.csdn.net/happycxz/article/details/78893690</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手动修改xxl-job-admin以支持Oracle数据库]]></title>
        <id>https://www.sunjianbo.com/xxl-job-oracle/</id>
        <link href="https://www.sunjianbo.com/xxl-job-oracle/">
        </link>
        <updated>2020-04-14T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基于xxl-job-2.1.2.Release</p>
</blockquote>
<p>直接使用:<a href="https://github.com/sunjianbo/xxl-job/tree/2.1.2">https://github.com/sunjianbo/xxl-job/tree/2.1.2</a></p>
<h2 id="docdbtables_xxl_jobsql">doc/db/tables_xxl_job.sql</h2>
<p>根据文件内容将其中的mysql语法修改为oracle</p>
<p>这里是我已改好的2.1.2版本对应的oracle文件:<a href="https://static.sunjianbo.com/code/sql/tables_xxl_job_oracle.sql">下载</a></p>
<h2 id="pomxml">/pom.xml</h2>
<p>注释</p>
<pre><code class="language-xml">&lt;!-- mysql --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;${mysql-connector-java.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>替换为</p>
<pre><code class="language-xml">&lt;!-- oracle --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.oracle&lt;/groupId&gt;
    &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;
    &lt;version&gt;11.2.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>根据自己的oracle本版选择对应的jdbc</p>
<blockquote>
<p>查看本版SQL:	<code>select version from v$instance;</code></p>
</blockquote>
<h2 id="srcmainresourcesapplicationproperties">/src/main/resources/application.properties</h2>
<p>注释</p>
<pre><code>#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8
#spring.datasource.driver-class-name=com.mysql.jdbc.Driver
#spring.datasource.tomcat.validation-query=SELECT 1
</code></pre>
<p>替换为</p>
<pre><code>spring.datasource.url=jdbc:oracle:thin:@127.0.0.1:3306:1521/xxl_job
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.tomcat.validation-query=SELECT 1 FROM DUAL
</code></pre>
<h2 id="srcmainresourcesmybatis-mapper">/src/main/resources/mybatis-mapper</h2>
<ul>
<li>查找mybatis-mapper目录下的所有</li>
</ul>
<pre><code>`
</code></pre>
<p>符号,替换为空</p>
<ul>
<li>查找</li>
</ul>
<pre><code>AS t
</code></pre>
<p>替换为t,搜索AS大写区分或者words</p>
<ul>
<li>查找</li>
</ul>
<pre><code>;
</code></pre>
<p>符号,替换为空</p>
<h2 id="srcmainresourcesmybatis-mapperxxljobgroupmapperxml">/src/main/resources/mybatis-mapper/XxlJobGroupMapper.xml</h2>
<p>将其中</p>
<pre><code>t.`order`
</code></pre>
<p>以及</p>
<pre><code>t.order
</code></pre>
<p>替换为</p>
<pre><code>t.&quot;ORDER&quot;
</code></pre>
<p>ORDER必须大写</p>
<h2 id="srcmainresourcesmybatis-mapperxxljobloggluemapperxml">/src/main/resources/mybatis-mapper/XxlJobLogGlueMapper.xml</h2>
<p>去掉select 出的<code>,rownum rn</code>将<code>where rn</code>改为<code>where rownum</code></p>
<p>修改后的代码:</p>
<pre><code>&lt;delete id=&quot;removeOld&quot; &gt;
   DELETE FROM xxl_job_logglue
   WHERE id NOT in(
      SELECT id FROM(
         SELECT id FROM xxl_job_logglue
         WHERE job_id = #{jobId}
         ORDER BY update_time desc
      ) t1 where rownum  &lt;![CDATA[ &lt;= ]]&gt;  #{limit}
   ) AND job_id = #{jobId}
&lt;/delete&gt;
</code></pre>
<h2 id="其他mapperxml">其他Mapper.xml</h2>
<ul>
<li>save的自增id修改为oracle格式</li>
<li>LIMIT的修改为oracle的rownum</li>
<li>增加jdbcType以防空值报错</li>
</ul>
<p><strong>注意:</strong></p>
<p>如果加jdbcType的话,XxlJobInfoMapper.xml中有两个属性写的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">{executorTimeout}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></span>{executorFailRetryCount},注意改成#{}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[telegram频道发布增加点赞评论等反馈功能]]></title>
        <id>https://www.sunjianbo.com/telegram-add-reactions/</id>
        <link href="https://www.sunjianbo.com/telegram-add-reactions/">
        </link>
        <updated>2020-04-01T02:57:10.000Z</updated>
        <content type="html"><![CDATA[<p>我自己经营了一个telegram的订阅频道:<a href="https://t.me/alittlefun">有点意思@alittlefun</a>用来分享一些有意思的图片什么的.</p>
<p>之前看到别人的订阅频道有emojies的点赞功能,觉得很好,类似这样:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/20200331110800.png" alt="" loading="lazy"></figure>
<p>所以想要放到自己频道来用,但是上网找了一圈只找到一个@like机器人可以满足我的要求,原文:<a href="http://x.2129.n8.nabble.com/Telegram-td30.html">http://x.2129.n8.nabble.com/Telegram-td30.html</a></p>
<p>但是它有一个问题,就是发出来的内容是通过转发方式出来的,这样就会在上面有个标志:</p>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/20200331111030.png" alt="" loading="lazy"></figure>
<p>处女座的我哪受得了这个啊.于是绞尽脑汁一顿折腾,终于找到了方法(＾－＾)V</p>
<h2 id="1使用botfather创建一个发布bot">1.使用@BotFather创建一个发布bot</h2>
<p>搜索到@BotFather --&gt; <code>/start</code> --&gt; <code>/newbot</code> --&gt; 输入自定义id --&gt; 输入自定义username</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/20200331111841.png" alt="step1" loading="lazy"></figure>
<h2 id="2使用controllerbot-新增并管理频道">2.使用@ControllerBot 新增并管理频道</h2>
<h3 id="21搜索到controllerbot-start-addchannel-复制上图标红位置的在botfather创建的token到controllerbot-粘贴">2.1搜索到@ControllerBot --&gt; <code>/start</code> --&gt; <code>/addchannel</code>--&gt; 复制上图标红位置的在BotFather创建的token到ControllerBot 粘贴</h3>
<figure data-type="image" tabindex="4"><img src="https://static.sunjianbo.com/20200331112452.png" alt="addchannel" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://static.sunjianbo.com/20200331112830.png" alt="token" loading="lazy"></figure>
<h3 id="22按照提示到自己的频道去把刚刚创建的bot增加为管理员">2.2按照提示到自己的频道去把刚刚创建的bot增加为管理员</h3>
<p>自己频道右上角Manage Channel --&gt; 点击Administrators --&gt; 点击左下角ADD ADMINISTRATOR --&gt; 搜索刚刚创建的bot(eg:alittlefun_bot)--&gt;完成管理员添加</p>
<h3 id="23转发一条自己频道的信息给controllerbot">2.3转发一条自己频道的信息给@ControllerBot</h3>
<h3 id="24输入城市名来确定时区直接输入shanghai">2.4输入城市名来确定时区,直接输入<code>shanghai</code></h3>
<figure data-type="image" tabindex="6"><img src="https://static.sunjianbo.com/20200331113549.png" alt="" loading="lazy"></figure>
<h3 id="25设置完成">2.5设置完成</h3>
<h2 id="3发布内容">3.发布内容</h2>
<h3 id="31点击上图create-post按钮或者手动打开之前创建的机器人alittlefun_bot-start-发送内容">3.1点击上图<strong>Create Post</strong>按钮或者手动打开之前创建的机器人(@alittlefun_bot) --&gt; <code>/start</code> --&gt; 发送内容</h3>
<figure data-type="image" tabindex="7"><img src="https://static.sunjianbo.com/20200331131340.png" alt="" loading="lazy"></figure>
<h3 id="32点击add-reactions按钮发送需要的emoji表情过去">3.2点击<strong>Add Reactions</strong>按钮,发送需要的emoji表情过去</h3>
<h3 id="33最后点击文本框下面send按钮设定发送时机参考图片">3.3最后点击文本框下面Send按钮,设定发送时机(参考图片)</h3>
<figure data-type="image" tabindex="8"><img src="https://static.sunjianbo.com/20200331132137.png" alt="" loading="lazy"></figure>
<h2 id="4总结">4.总结</h2>
<p>经过以上步骤即可实现在自己的频道发布带emoji点赞反馈的内容.</p>
<p>步骤可以简单归纳为</p>
<ol>
<li>
<p>@BotFather创建自定义bot</p>
</li>
<li>
<p>@ControllerBot绑定自定义bot和频道</p>
</li>
<li>
<p>在自定义bot发布内容</p>
</li>
</ol>
<p>同时细心的小伙伴一定也发现了通过这个bot还可以实现<strong>附加媒体</strong>,<strong>增加评论</strong>,<strong>附加URL</strong>以及<strong>定时发送</strong>的功能,都可以自行研究一下.</p>
]]></content>
    </entry>
</feed>