<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-03-18T06:28:26.900Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[github pages url重定向的变相解决方法]]></title>
        <id>https://www.sunjianbo.com/github-pages-rewrite/</id>
        <link href="https://www.sunjianbo.com/github-pages-rewrite/">
        </link>
        <updated>2020-03-12T02:07:10.000Z</updated>
        <content type="html"><![CDATA[<p>这也是从WordPress迁移到Gridea&amp;github pages的后遗症之一.</p>
<p>我在WP那边的url格式是https://www.sunjianbo.com/xxx.html,而弄好Gridea之后发现url格式是https://www.sunjianbo.com/post/xxx/.因为是老站嘛,搜索引擎还是有一些关键词可以搜到的,所以昨天发现了问题,从搜索引擎那边链接打开的页面都会404.</p>
<p>我第一个想法就是通过.htaccess做url的rewrite,但是搜索一下发现github pages并不支持这种方式.</p>
<p>好在还知道<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2; url='/'&quot;&gt;</code>标签可以做页面的定时跳转和刷新,再结合使用<code>&lt;link rel=&quot;canonical&quot; href=&quot;&quot; /&gt;</code>标签来告诉搜索引擎新的规范链接地址.</p>
<p>思路说完了,那么以下是详细步骤:</p>
<h2 id="1修改gridea主题设置">1.修改Gridea主题设置</h2>
<p>开启,精简url模式这是为了去掉url中的/post/,不用gridea的可以无视.<img src="http://static.sunjianbo.com/20200312102504.png" alt="gridea" loading="lazy"></p>
<h2 id="2批量创建html文件">2.批量创建html文件</h2>
<p>我这里通过Python代码遍历post目录下所有文章,提取文件名,替换后缀名,在指定目录生成.html文件.</p>
<p>代码如下:</p>
<pre><code class="language-Python">#conding=utf8
import os
g = os.walk(&quot;D:\IDE\Gridea\Documents\Gridea\posts&quot;)
out = &quot;D:\IDE\Gridea\Documents\Gridea\output\&quot;
for path,dir_list,file_list in g:
    print(len(file_list))
    for file_name in file_list:
        # print(os.path.join(path, file_name) )

        print(os.path.splitext(file_name)[0])
        outName = os.path.splitext(file_name)[0] + &quot;.html&quot;
        with open(out + outName, 'w') as f:  # open()函数可以判断文件是否存在，如果不存在，则创建文件
            myurl = &quot;www.sunjianbo.com/&quot; +os.path.splitext(file_name)[0]
            message = &quot;&quot;&quot;&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=https://myurl/&quot;&gt;
    &lt;link rel=&quot;canonical&quot; href=&quot;https://myurl/&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;&quot;&quot;&quot;
            message = message.replace(&quot;myurl&quot;,myurl)
            f.write(message)
</code></pre>
<h2 id="3上传到github">3.上传到github</h2>
<p>打开.html查看是否没有问题,删除多余的没用文件,比如我这里还生成了一个<code>.DS_Store.html</code>*´∀`)</p>
<p>然后手动上传到github,不能通过Gridea上传因为他会清空output目录自己再生成一遍文章,我们的html文件会在同步前被删除.</p>
<p>到output目录打开终端</p>
<pre><code class="language-git">git add .
git commit -m &quot;for rewrite&quot;
git pustt
</code></pre>
<p>当然网页上传也可以,不过上传文件限制一次100,文章多的话更麻烦一点.</p>
<h2 id="4最后到搜索引擎搜索关键字测试一下吧">4.最后到搜索引擎搜索关键字测试一下吧.</h2>
<h2 id="ps可以将html文件上传github的不同目录来满足不同url格式的支持">PS:可以将.html文件上传github的不同目录来满足不同url格式的支持.</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea主题修改之自动摘要]]></title>
        <id>https://www.sunjianbo.com/gridea-auto-excerpt/</id>
        <link href="https://www.sunjianbo.com/gridea-auto-excerpt/">
        </link>
        <updated>2020-03-11T06:42:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Gridea的部分主题并不带有自动摘要功能,如果需要摘要得先在文章中手动插入<code>&lt;!--more--&gt;</code>标记.否则首页就是光溜溜的一片标题,看起来很不舒服.</p>
<p>而且像我这样直接从WordPress迁移很多文章过来的也不可能挨篇文章去加<code>&lt;!--more--&gt;</code>标记,所以动手修改主题以达到首页自动显示摘要的目的.</p>
<p>本文以Gridea自带主题&lt;Simple1.1.0&gt;为例,讲述如何通过js代码修改添加自定义配置并完成自动摘要功能,修改方法大同小异,其他主题也可以参考.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Gridea的部分主题并不带有自动摘要功能,如果需要摘要得先在文章中手动插入<code>&lt;!--more--&gt;</code>标记.否则首页就是光溜溜的一片标题,看起来很不舒服.</p>
<p>而且像我这样直接从WordPress迁移很多文章过来的也不可能挨篇文章去加<code>&lt;!--more--&gt;</code>标记,所以动手修改主题以达到首页自动显示摘要的目的.</p>
<p>本文以Gridea自带主题&lt;Simple1.1.0&gt;为例,讲述如何通过js代码修改添加自定义配置并完成自动摘要功能,修改方法大同小异,其他主题也可以参考.</p>
<!--more-->
<h2 id="1增加自定义配置">1.增加自定义配置</h2>
<p>编辑文件<code>%Gridea%\themes\simple\config.json</code>,<code>%Gridea%</code>就是Gridea设置中的站点源文件路径.</p>
<p>在合适的位置上添加以下代码:</p>
<pre><code class="language-js">	{
      &quot;name&quot;: &quot;is_auto_excerpt&quot;,
      &quot;label&quot;: &quot;是否启用自动摘要&quot;,
      &quot;group&quot;: &quot;自动摘要&quot;,
      &quot;value&quot;: true,
      &quot;type&quot;: &quot;switch&quot;
    },
    {
      &quot;name&quot;: &quot;auto_excerpt_line&quot;,
      &quot;label&quot;: &quot;自动摘要选取行数&quot;,
      &quot;group&quot;: &quot;自动摘要&quot;,
      &quot;value&quot;: &quot;3&quot;,
      &quot;type&quot;: &quot;input&quot;
    },
</code></pre>
<p>就完成了主题的页面设置功能,自动摘要选取的行数可以自定义</p>
<p>效果图:</p>
<figure data-type="image" tabindex="1"><img src="http://static.sunjianbo.com/gridea-auto-excerpt/image-20200311142153575.png" alt="image-20200311142153575" loading="lazy"></figure>
<h2 id="2首页编写自动摘要功能">2.首页编写自动摘要功能</h2>
<p>编辑文件<code>%Gridea%\themes\simple\templates\index.ejs</code>在如图所示位置添加代码:</p>
<figure data-type="image" tabindex="2"><img src="http://static.sunjianbo.com/gridea-auto-excerpt/image-20200311142947299.png" alt="image-20200311142947299" loading="lazy"></figure>
<pre><code class="language-js">&lt;% if (post.abstract) { %&gt;
	&lt;!-- 有手动摘要则加个more链接 --&gt;
	&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;more →&lt;/a&gt;
&lt;% } else if (site.customConfig.is_auto_excerpt) { %&gt;
	&lt;!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 --&gt;
	&lt;% var br_position = 0 %&gt;
	&lt;% for (var br_count = 0; br_count &lt; site.customConfig.auto_excerpt_line; br_count++) { %&gt;
		&lt;% br_position = post.content.indexOf('\n',br_position + 1) %&gt;
		&lt;% if(br_position &lt; 0) { break } %&gt;
	&lt;% } %&gt;
	&lt;% if(br_position &gt; 0) { %&gt;
		&lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;
			&lt;% if(post.content.substring(0, br_position + 1).indexOf(&quot;&lt;code&quot;) &gt; 0) { %&gt;
				&lt;!-- 自动摘要出来的内容有&lt;code则补上结尾,防止格式错误 --&gt;
				&lt;/code&gt;&lt;/pre&gt;
			&lt;% } %&gt;
		&lt;p&gt;
		&lt;!-- 加个more链接 --&gt;
		&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;more →&lt;/a&gt;
	&lt;% } %&gt;
&lt;% } %&gt;
</code></pre>
<h2 id="3保存重启gridea预览查看效果">3.保存重启Gridea预览查看效果</h2>
<h2 id="4优化">4.优化</h2>
<p>接下来是一个小优化,调整了一下<code>more →</code>的的样式,看起来更顺眼一些.</p>
<p>编辑文件<code>%Gridea%\themes\simple\assets\styles\main.less</code>在最后添加:</p>
<pre><code class="language-css">.post-item .left .post-abstract a {
  color: #4c6ef5;
  border-bottom: 1px dotted #4c6ef5;
  transition: all 0.3s;
}
</code></pre>
<p>效果图</p>
<figure data-type="image" tabindex="3"><img src="http://static.sunjianbo.com/gridea-auto-excerpt/image-20200311150147647.png" alt="image-20200311150147647" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WordPress文章导出迁移到Gridea]]></title>
        <id>https://www.sunjianbo.com/wordpress-to-gridea/</id>
        <link href="https://www.sunjianbo.com/wordpress-to-gridea/">
        </link>
        <updated>2020-03-10T04:12:05.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>
<p><a href="https://gridea.dev/">Gridea</a>是一个静态博客写作客户端,类似hexo,hugo等,不过可以全面图形化操作,更简单,更方便.</p>
</li>
<li>
<p>本次导出主要基于<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter">WordPress to Gridea Exporter</a>插件,是我根据<a href="https://github.com/SchumacherFM/wordpress-to-hugo-exporter/">WordPress to Hugo Exporter<br>
</a>简单修改而来,感谢原作者(<sup>人</sup>)</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>
<p><a href="https://gridea.dev/">Gridea</a>是一个静态博客写作客户端,类似hexo,hugo等,不过可以全面图形化操作,更简单,更方便.</p>
</li>
<li>
<p>本次导出主要基于<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter">WordPress to Gridea Exporter</a>插件,是我根据<a href="https://github.com/SchumacherFM/wordpress-to-hugo-exporter/">WordPress to Hugo Exporter<br>
</a>简单修改而来,感谢原作者(<sup>人</sup>)</p>
</li>
</ul>
<!-- more -->
<blockquote>
<p>注意:如果你使用了类似WP Database Backup等备份插件,记得去删除一些历史的备份文件,否则导出文件可能会很大</p>
</blockquote>
<h2 id="操作方法">操作方法</h2>
<ol>
<li>
<p>登陆wordpress后台通过快速编辑将每一篇文章的别名修改为英文,否则导出的文章会出现乱码.虽然gridea能识别,但是链接也会变成乱码,看着闹挺.<br>
<img src="http://static.sunjianbo.com/wordpress-to-gridea/alias.png" alt="alias" loading="lazy"></p>
</li>
<li>
<p>下载WordPress to Gridea Exporter并安装到wordpress上,启用.<br>
<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter/archive/master.zip">https://github.com/sunjianbo/WordPress-to-Gridea-Exporter/archive/master.zip</a></p>
</li>
<li>
<p>点击后台管理菜单的工具--&gt;Export to Hugo然后浏览器会自动下载一个名为hugo-export.zip的文件,所需的东西都在里面了.<br>
<img src="http://static.sunjianbo.com/wordpress-to-gridea/action.png" alt="action" loading="lazy"></p>
</li>
<li>
<p>提取hugo-export.zip文件中的posts文件下的所有md文件到Documents\Gridea\posts目录下(如果不知道该目录在那,查看Gridea的设置)</p>
</li>
<li>
<p>重启Gridea查看并预览是否已经读取到相关文章</p>
</li>
<li>
<p>wordpress中隐藏的文章全部设为草稿了,如需发布自行编辑一下</p>
</li>
<li>
<p>文章中的图片有可能需要重新处理一下,wp媒体库的图片在压缩包中wp-content/uploads目录中</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome开发者工具查看元素绑定的事件]]></title>
        <id>https://www.sunjianbo.com/chrome-kai-fa-zhe-gong-ju-cha-kan-yuan-su-bang-ding-de-shi-jian/</id>
        <link href="https://www.sunjianbo.com/chrome-kai-fa-zhe-gong-ju-cha-kan-yuan-su-bang-ding-de-shi-jian/">
        </link>
        <updated>2020-03-09T08:59:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="方法一">方法一</h2>
<p>1.右键检查or手动打开开发者工具,选中对应元素<br>
2.点击Event Listeners标签<br>
<img src="http://static.sunjianbo.com/Chrome%20Developer%20Tools%20view%20Listeners/step1.1.png" alt="step1.1" loading="lazy"><br>
3.取消勾选Ancestors All以筛选出指定选中元素对应的事件<br>
<img src="http://static.sunjianbo.com/Chrome%20Developer%20Tools%20view%20Listeners/step1.2.png" alt="step1.2" loading="lazy"></p>
<h2 id="方法二">方法二</h2>
<p>有时会发生方法一无法看到对应的事件,取消勾选Ancestors All以后一片空白,可以试试方法二.<br>
1.打开开发者工具,切换到Sources标签页<br>
<img src="http://static.sunjianbo.com/Chrome%20Developer%20Tools%20view%20Listeners/step2.1.png" alt="step2.1" loading="lazy"><br>
展开Event Listeners Breakpoints,寻找指定事件勾选(我这里用click事件举例),这里相当于对相关事件下了断点<br>
<img src="http://static.sunjianbo.com/Chrome%20Developer%20Tools%20view%20Listeners/step2.2.png" alt="step2.2" loading="lazy"><br>
3.然后去操作页面来触发事件,这时就会进入断点,逐步寻找到你需要的代码.比较麻烦,无奈之举.<br>
<img src="http://static.sunjianbo.com/Chrome%20Developer%20Tools%20view%20Listeners/step2.3.png" alt="step2.3" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea——github pages搭建个人博客利器]]></title>
        <id>https://www.sunjianbo.com/gridea-github-page-li-qi/</id>
        <link href="https://www.sunjianbo.com/gridea-github-page-li-qi/">
        </link>
        <updated>2020-02-25T07:42:55.000Z</updated>
        <content type="html"><![CDATA[<p>以前也想过搞github pages做博客,但是一搜教程看着那一步步超级麻烦的操作步骤,无奈放弃.<br>
今天浏览网站时无意中发现了Gridea,顿时惊为天人.<br>
它提供一个美观方便的客户端工具,以此简化了github pages的操作方法.使小白也能简简单单搭建一个个人博客了.<br>
同时还支持MarkDown,简直不能再妙!</p>
<h2 id="官方网站">官方网站:</h2>
<p><a href="https://gridea.dev/">https://gridea.dev/</a></p>
<h2 id="github主页">github主页:</h2>
<p><a href="https://github.com/getgridea/gridea">https://github.com/getgridea/gridea</a></p>
<h2 id="简单教程">简单教程:</h2>
<p><a href="https://fehey.com/post/hve-notes-start/">https://fehey.com/post/hve-notes-start/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot通过java -jar运行实现ApplicationContextAware接口报空指针NUllPointerException]]></title>
        <id>https://www.sunjianbo.com/springboot-applicationcontextaware-nullpointerexception/</id>
        <link href="https://www.sunjianbo.com/springboot-applicationcontextaware-nullpointerexception/">
        </link>
        <updated>2019-07-22T00:06:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="先描述背景">先描述背景：</h2>
<p>自定义了一个实现ApplicationContextAware的自定义类，之前测试都是用IDE的run as application方式启动项目，没有错误。</p>
<p>后来打包成jar文件通过java -jar运行即报空指针异常</p>
<blockquote>
<p>Caused by: java.lang.NullPointerException: null<br>
at com.ceair.b2t.messagecenter.SpringContextUtil.getBean(SpringContextUtil.java:41) ~[classes!/:na]</p>
</blockquote>
<h2 id="原因">原因:</h2>
<p>直接原因是applicationContext为空，即没有注入</p>
<p>背后的原因是实现ApplicationContextAware的自定义类和使用applicationContext的类加载顺序问题。</p>
<p><strong>一定要把定义的ApplicationContextAware工具类加载顺序放到调用类的前面</strong></p>
<h2 id="解决方案">解决方案:</h2>
<p>就是在调用类上添加注解</p>
<pre><code>@DependsOn(&quot;springContextUtil&quot;)
</code></pre>
<p>该注解用于声明当前bean依赖于另外一个bean。所依赖的bean会被容器确保在当前bean实例化之前被实例化。</p>
<p>题外话：</p>
<p>这样看来两种run项目方式至少在类加载顺序上是有区别的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FileZilla支持Windows XP版本官方下载地址]]></title>
        <id>https://www.sunjianbo.com/filezilla-for-windows-xp-download/</id>
        <link href="https://www.sunjianbo.com/filezilla-for-windows-xp-download/">
        </link>
        <updated>2019-04-09T17:59:04.000Z</updated>
        <content type="html"><![CDATA[<p>FileZilla很早就已经不支持xp系统了</p>
<p>3.9.0.1是最后一个支持的版本</p>
<p>网上不太好找官方的下载地址，都是第三方的，安全性无法保证。</p>
<p>所以为了方便一些特殊用户，我找到以后写了出来</p>
<p>下面是官方下载地址：</p>
<p><a href="https://download.filezilla-project.org/client/FileZilla_3.9.0.1_win32-setup.exe?nowrap">https://download.filezilla-project.org/client/FileZilla_3.9.0.1_win32-setup.exe?nowrap</a></p>
<p>备注：</p>
<p>安装时会提示不支持，可以忽略，能够正常使用，查看更新日志，应该是在3.8以后停止支持的，但是后面还兼容了一段时间。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最简单解决linux解压缩乱码问题]]></title>
        <id>https://www.sunjianbo.com/the-easiest-solution-to-linux-decompression-garbled/</id>
        <link href="https://www.sunjianbo.com/the-easiest-solution-to-linux-decompression-garbled/">
        </link>
        <updated>2018-12-25T18:07:26.000Z</updated>
        <content type="html"><![CDATA[<p>因为在windows下压缩的文件是使用(gbk,gb18030)编码的，所以在linux(utf-8)下面直接解压有编码问题</p>
<p>网上说的unzip -O之类的都不太靠谱</p>
<p>后来终于找到一个最简单的方法，几乎没什么成本。</p>
<p>就是安装<code>unzip-natspec</code>来替换<code>unzip</code></p>
<pre><code>yay -Ss unzip-natspec
#unzip-natspec 与 unzip 有冲突。删除 unzip 吗？ [y/N]y
</code></pre>
<p>unzip-natspec可以自动识别文件编码，用法和unzip一样，直接&quot;unzip xxx.zip&quot;即可，非常方便！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[No value specified for 'BigDecimal']]></title>
        <id>https://www.sunjianbo.com/no-value-specified-for-bigdecimal/</id>
        <link href="https://www.sunjianbo.com/no-value-specified-for-bigdecimal/">
        </link>
        <updated>2018-07-24T01:52:34.000Z</updated>
        <content type="html"><![CDATA[<p>使用<strong>org.apache.commons.beanutils.BeanUtils</strong>进行对象拷贝时，遇到BigDecimal的属性会报错</p>
<blockquote>
<p>No value specified for 'BigDecimal'</p>
</blockquote>
<p>这时候定义自己的转换器即可</p>
<pre><code>// 这里一定要注册默认值，使用null也可以    
BigDecimalConverter bd = new BigDecimalConverter(BigDecimal.ZERO);    
ConvertUtils.register(bd, java.math.BigDecimal.class);
</code></pre>
<p>还有一些其他类型可能也需要如此处理，简单一点的，使用<strong>org.springframework.beans.BeanUtils</strong>则不会有这样的问题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web大规模高并发请求和抢购的解决方案]]></title>
        <id>https://www.sunjianbo.com/high-concurrency-requests-and-snap-up/</id>
        <link href="https://www.sunjianbo.com/high-concurrency-requests-and-snap-up/">
        </link>
        <updated>2018-07-09T22:12:16.000Z</updated>
        <content type="html"><![CDATA[<p>转载的,我看得地方也是转载的,所以就不贴原文地址了,文章写得很细致,可以一看.</p>
<p>电商的秒杀和抢购，对我们来说，都不是一个陌生的东西。然而，从技术的角度来说，这对于Web系统是一个巨大的考验。当一个Web系统，在一秒钟内收到数以万计甚至更多请求时，系统的优化和稳定至关重要。这次我们会关注秒杀和抢购的技术实现和优化，同时，从技术层面揭开，为什么我们总是不容易抢到火车票的原因？</p>
<h2 id="一-大规模并发带来的挑战">一、大规模并发带来的挑战</h2>
<p>在过去的工作中，我曾经面对过5w每秒的高并发秒杀功能，在这个过程中，整个Web系统遇到了很多的问题和挑战。如果Web系统不做针对性的优化，会轻而易举地陷入到异常状态。我们现在一起来讨论下，优化的思路和方法哈。</p>
<h3 id="1-请求接口的合理设计">1. 请求接口的合理设计</h3>
<p>一个秒杀或者抢购页面，通常分为2个部分，一个是静态的HTML等内容，另一个就是参与秒杀的Web后台请求接口。</p>
<p>通常静态HTML等内容，是通过CDN的部署，一般压力不大，核心瓶颈实际上在后台请求接口上。这个后端接口，必须能够支持高并发请求，同时，非常重要的一点，必须尽可能“快”，在最短的时间里返回用户的请求结果。为了实现尽可能快这一点，接口的后端存储使用内存级别的操作会更好一点。仍然直接面向MySQL之类的存储是不合适的，如果有这种复杂业务的需求，都建议采用异步写入。</p>
<p>当然，也有一些秒杀和抢购采用“滞后反馈”，就是说秒杀当下不知道结果，一段时间后才可以从页面中看到用户是否秒杀成功。但是，这种属于“偷懒”行为，同时给用户的体验也不好，容易被用户认为是“暗箱操作”。</p>
<h3 id="2-高并发的挑战一定要快">2. 高并发的挑战：一定要“快”</h3>
<p>我们通常衡量一个Web系统的吞吐率的指标是QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键。举个例子，我们假设处理一个业务请求平均响应时间为100ms，同时，系统内有20台Apache的Web服务器，配置MaxClients为500个（表示Apache的最大连接数目）。</p>
<p>那么，我们的Web系统的理论峰值QPS为（理想化的计算方式）：</p>
<blockquote>
<p>20*500/0.1 = 100000 （10万QPS）</p>
</blockquote>
<p>咦？我们的系统似乎很强大，1秒钟可以处理完10万的请求，5w/s的秒杀似乎是“纸老虎”哈。实际情况，当然没有这么理想。在高并发的实际场景下，机器都处于高负载的状态，在这个时候平均响应时间会被大大增加。</p>
<p>就Web服务器而言，Apache打开了越多的连接进程，CPU需要处理的上下文切换也越多，额外增加了CPU的消耗，然后就直接导致平均响应时间增加。因此上述的MaxClient数目，要根据CPU、内存等硬件因素综合考虑，绝对不是越多越好。可以通过Apache自带的abench来测试一下，取一个合适的值。然后，我们选择内存操作级别的存储的Redis，在高并发的状态下，存储的响应时间至关重要。网络带宽虽然也是一个因素，不过，这种请求数据包一般比较小，一般很少成为请求的瓶颈。负载均衡成为系统瓶颈的情况比较少，在这里不做讨论哈。</p>
<p>那么问题来了，假设我们的系统，在5w/s的高并发状态下，平均响应时间从100ms变为250ms（实际情况，甚至更多）：</p>
<blockquote>
<p>20*500/0.25 = 40000 （4万QPS）</p>
</blockquote>
<p>于是，我们的系统剩下了4w的QPS，面对5w每秒的请求，中间相差了1w。</p>
<p>然后，这才是真正的恶梦开始。举个例子，高速路口，1秒钟来5部车，每秒通过5部车，高速路口运作正常。突然，这个路口1秒钟只能通过4部车，车流量仍然依旧，结果必定出现大塞车。（5条车道忽然变成4条车道的感觉）</p>
<p>同理，某一个秒内，20*500个可用连接进程都在满负荷工作中，却仍然有1万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。</p>
<p>其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个Web请求响应时间拉得很长，逐渐将Web服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。</p>
<p>更可怕的问题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，恶性循环最终导致“雪崩”（其中一台Web机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环），将整个Web系统拖垮。</p>
<h3 id="3-重启与过载保护">3. 重启与过载保护</h3>
<p>如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。</p>
<p>秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在CGI入口层，快速将客户的直接请求返回。</p>
<h2 id="二-作弊的手段进攻与防守">二、作弊的手段：进攻与防守</h2>
<p>秒杀和抢购收到了“海量”的请求，实际上里面的水分是很大的。不少用户，为了“抢“到商品，会使用“刷票工具”等类型的辅助工具，帮助他们发送尽可能多的请求到服务器。还有一部分高级用户，制作强大的自动请求脚本。这种做法的理由也很简单，就是在参与秒杀和抢购的请求中，自己的请求数目占比越多，成功的概率越高。</p>
<p>这些都是属于“作弊的手段”，不过，有“进攻”就有“防守”，这是一场没有硝烟的战斗哈。</p>
<h3 id="1-同一个账号一次性发出多个请求">1. 同一个账号，一次性发出多个请求</h3>
<p>部分用户通过浏览器的插件或者其他工具，在秒杀开始的时间里，以自己的账号，一次发送上百甚至更多的请求。实际上，这样的用户破坏了秒杀和抢购的公平性。</p>
<p>这种请求在某些没有做数据安全处理的系统里，也可能造成另外一种破坏，导致某些判断条件被绕过。例如一个简单的领取逻辑，先判断用户是否有参与记录，如果没有则领取成功，最后写入到参与记录中。这是个非常简单的逻辑，但是，在高并发的场景下，存在深深的漏洞。多个并发请求通过负载均衡服务器，分配到内网的多台Web服务器，它们首先向存储发送查询请求，然后，在某个请求成功写入参与记录的时间差内，其他的请求获查询到的结果都是“没有参与记录”。这里，就存在逻辑判断被绕过的风险。</p>
<p><strong>应对方案：</strong></p>
<p>在程序入口处，一个账号只允许接受1个请求，其他请求过滤。不仅解决了同一个账号，发送N个请求的问题，还保证了后续的逻辑流程的安全。实现方案，可以通过Redis这种内存缓存服务，写入一个标志位（只允许1个请求写成功，结合watch的乐观锁的特性），成功写入的则可以继续参加。</p>
<p>或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。</p>
<h3 id="2-多个账号一次性发送多个请求">2. 多个账号，一次性发送多个请求</h3>
<p>很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，也导致了出现了一些特殊的工作室，通过编写自动注册脚本，积累了一大批“僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的“僵尸粉“的来源）。举个例子，例如微博中有转发抽奖的活动，如果我们使用几万个“僵尸号”去混进去转发，这样就可以大大提升我们中奖的概率。</p>
<p>这种账号，使用在秒杀和抢购里，也是同一个道理。例如，iPhone官网的抢购，火车票黄牛党。</p>
<p><strong>应对方案：</strong></p>
<p>这种场景，可以通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求：</p>
<p>弹出验证码，最核心的追求，就是分辨出真实用户。因此，大家可能经常发现，网站弹出的验证码，有些是“鬼神乱舞”的样子，有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的“自动脚本”可以通过图片识别里面的字符，然后让脚本自动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。</p>
<p>直接禁止IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口IP的，可能会有“误伤“。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。</p>
<h3 id="3-多个账号不同ip发送不同请求">3. 多个账号，不同IP发送不同请求</h3>
<p>所谓道高一尺，魔高一丈。有进攻，就会有防守，永不休止。这些“工作室”，发现你对单机IP请求频率有控制之后，他们也针对这种场景，想出了他们的“新进攻方案”，就是不断改变IP。</p>
<p>有同学会好奇，这些随机IP服务怎么来的。有一些是某些机构自己占据一批独立IP，然后做成一个随机代理IP的服务，有偿提供给这些“工作室”使用。还有一些更为黑暗一点的，就是通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发IP包，普通用户的电脑被变成了IP代理出口。通过这种做法，黑客就拿到了大量的独立IP，然后搭建为随机IP服务，就是为了挣钱。</p>
<p><strong>应对方案：</strong></p>
<p>说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。</p>
<p>僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。</p>
<h3 id="4-火车票的抢购">4. 火车票的抢购</h3>
<p>看到这里，同学们是否明白你为什么抢不到火车票？如果你只是老老实实地去抢票，真的很难。通过多账号的方式，火车票的黄牛将很多车票的名额占据，部分强大的黄牛，在处理验证码方面，更是“技高一筹“。</p>
<p>高级的黄牛刷票时，在识别验证码的时候使用真实的人，中间搭建一个展示验证码图片的中转软件服务，真人浏览图片并填写下真实验证码，返回给中转软件。对于这种方式，验证码的保护限制作用被废除了，目前也没有很好的解决方案。</p>
<p>因为火车票是根据×××实名制的，这里还有一个火车票的转让操作方式。大致的操作方式，是先用买家的×××开启一个抢票工具，持续发送请求，黄牛账号选择退票，然后黄牛买家成功通过自己的×××购票成功。当一列车厢没有票了的时候，是没有很多人盯着看的，况且黄牛们的抢票工具也很强大，即使让我们看见有退票，我们也不一定能抢得过他们哈。</p>
<p>最终，黄牛顺利将火车票转移到买家的×××下。</p>
<p><strong>解决方案：</strong></p>
<p>并没有很好的解决方案，唯一可以动心思的也许是对账号数据进行“数据挖掘”，这些黄牛账号也是有一些共同特征的，例如经常抢票和退票，节假日异常活跃等等。将它们分析出来，再做进一步处理和甄别。</p>
<h2 id="三-高并发下的数据安全">三、高并发下的数据安全</h2>
<p>我们知道在多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用MySQL的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。</p>
<h3 id="1-超发的原因">1. 超发的原因</h3>
<p>假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景）</p>
<p>在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。</p>
<h3 id="2-悲观锁思路">2. 悲观锁思路</h3>
<p>解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。</p>
<p>悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。</p>
<p>虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。</p>
<h3 id="3-fifo队列思路">3. FIFO队列思路</h3>
<p>那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。</p>
<p>然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。</p>
<h3 id="4-乐观锁思路">4. 乐观锁思路</h3>
<p>这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。</p>
<p>有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。</p>
<h2 id="四-小结">四、小结</h2>
<p>互联网正在高速发展，使用互联网服务的用户越多，高并发的场景也变得越来越多。电商秒杀和抢购，是两个比较典型的互联网高并发场景。虽然我们解决问题的具体技术方案可能千差万别，但是遇到的挑战却是相似的，因此解决问题的思路也异曲同工。</p>
]]></content>
    </entry>
</feed>