<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-09-01T08:44:21.847Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[简七理财001-小白理财第一课]]></title>
        <id>https://www.sunjianbo.com/jianqilicai001/</id>
        <link href="https://www.sunjianbo.com/jianqilicai001/">
        </link>
        <updated>2020-08-31T07:19:30.000Z</updated>
        <content type="html"><![CDATA[<p><strong>书名:</strong>	简七理财001-小白理财第一课</p>
<p><strong>作者:</strong>	简七理财</p>
<p><strong>阅读时间:</strong>	20200826~20200827</p>
<hr>
<h3 id="读后感">读后感:</h3>
<p>拿到掌阅f1第一天,随便找了本看起来顺眼的书开始打卡</p>
<p>断断续续累积两个小时读完,这个时间用的有点长了,以后这种书还是要读的更快一点</p>
<p>书看起来是13年的,很多东西过时了,甚至里面还推荐大家买P2P理财【瑟瑟发抖】</p>
<p>整个看下来发现最有用的还是自我投资这一部分,其他的看过就忘就好,对我来说没什么价值</p>
<h3 id="笔记">笔记:</h3>
<p>理财不是让我们不花钱，而是让我们成为金钱的主人，通过规划去更好的更安心的生活</p>
<p>一个人能够取得的最终成就，不是由你的起点决定的，而是在过程中是否能有清晰的目标、保持规划并且严格的执行。所以你的生活会变得怎么样，完全取决于你愿不愿意从现在开始去规划自己的未来。</p>
<p>投资自己四部曲</p>
<ol>
<li>
<p>投资自己的视野和洞察力</p>
<p>方式一是阅读，大量的阅读。方式二是旅行，勇敢滴旅行。</p>
</li>
<li>
<p>投资自己挑战的勇气和技巧</p>
<p>如何定义“挑战”？手到擒来那不算，要就要踮起脚尖来都够不到，必须跳起来才有机会触到的才是真正的挑战。</p>
<p>☆尝试一次练摊儿：比如在圣诞节晚上去商业街兜售小饰品，并与城管斗智斗勇； ☆尝试一个人旅行：从做攻略到完成旅行全程靠自己完成，如要增加难度可考虑出境游；</p>
<p>☆尝试在100人面前演讲：主动申请一个机会，在一群人面前演讲一个你感兴趣的题目； ☆坚持一种运动的习惯：例如坚持晨跑、或者坚持游泳三个月。</p>
</li>
<li>
<p>投资自己独特的眼光和方法论</p>
<p>除了阅读、学习、体验之外，还要会总结和提炼</p>
</li>
<li>
<p>投资自己的心态和情绪管理</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA锁相关]]></title>
        <id>https://www.sunjianbo.com/synchronized/</id>
        <link href="https://www.sunjianbo.com/synchronized/">
        </link>
        <updated>2020-08-28T08:26:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java中锁的概念">JAVA中锁的概念</h1>
<ul>
<li>
<p><strong>自旋锁</strong>:为了不放弃CPU执行事件,循环的使用CAS技术对数据尝试进行更新,直至成功。</p>
</li>
<li>
<p><strong>悲观锁</strong>:假定会发生并发冲突,同步所有对数据的相关操作,从读数据就开始上锁。</p>
</li>
<li>
<p><strong>乐观锁</strong>:假定没有冲突,在修改数据时如果发现数据和之前获取的不一致,则读最新数据,修改后重试修改。</p>
</li>
<li>
<p><strong>独享锁(写)</strong>:给资源加上写锁,线程可以修改资源,其他线程不能再加锁;(单写)</p>
</li>
<li>
<p><strong>共享锁(读)</strong>:给资源加上读锁后只能读不能改,其他线程也只能加读锁,不能加写锁;(多读)</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200827093337312.png" alt="image-20200827093337312" loading="lazy"></figure>
<ul>
<li><strong>可重入锁、不可重入锁</strong>:线程拿到一把锁之后,可以自由进入同一把锁所同步的其他代码。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200827093401077.png" alt="image-20200827093401077" loading="lazy"></figure>
<ul>
<li><strong>公平锁、非公平锁</strong>:争抢锁的顺序,如果是按先来后到,则为公平。</li>
</ul>
<p>几种重要的锁实现方式: synchronized、 ReentrantLock、 ReentrantReadWriteLock</p>
<h1 id="同步关键字-synchronized">同步关键字 synchronized</h1>
<h2 id="概念">概念</h2>
<p>属于最基本的线程通信机制,基于对象监视器实现的。</p>
<p>Java中的每个对象都与一个监视器相关联,一个线程可以锁定或解锁。</p>
<p>一次只有一个线程可以锁定监视器。</p>
<p>试图锁定该监视器的任何其他线程都会被阻塞,直到它们可以获得该监视器上的锁定为止。</p>
<h3 id="持性">持性:</h3>
<ul>
<li>可重入</li>
<li>独享</li>
<li>悲观锁</li>
</ul>
<h3 id="锁的范围">锁的范围:</h3>
<ul>
<li>类锁</li>
<li>对象锁</li>
<li>锁消除</li>
<li>锁粗化</li>
</ul>
<h3 id="可见性">可见性</h3>
<p>同步关鍵字,不仅是实现同步,根据JMM规定还能保证可见性(读取最新主内存数据,结束后写入主内存)</p>
<h2 id="代码示例">代码示例</h2>
<h3 id="synchronized代码示例">synchronized代码示例</h3>
<pre><code class="language-java">// 锁 方法(静态/非静态),代码块(对象/类)
public class ObjectSyncDemo1 {

    //普通方法+同步关键字,不能同步,因为锁的是对象,main里两个线程创建了两个对象
    public synchronized void test1(){
		try {
			System.out.println(Thread.currentThread() + &quot; 我开始执行&quot;);
			Thread.sleep(3000L);
			System.out.println(Thread.currentThread() + &quot; 我执行结束&quot;);
		} catch (InterruptedException e) {
		}
    }
    
    //static方法+同步关键字,能同步,因为锁的是类
    public synchronized static void test1(){
		try {
			System.out.println(Thread.currentThread() + &quot; 我开始执行&quot;);
			Thread.sleep(3000L);
			System.out.println(Thread.currentThread() + &quot; 我执行结束&quot;);
		} catch (InterruptedException e) {
		}
    }
        
    //synchronized (this),不能同步
    static Object temp = new Object();
    public void test1() {
		synchronized (this) {
            try {
                System.out.println(Thread.currentThread() + &quot; 我开始执行&quot;);
                Thread.sleep(3000L);
                System.out.println(Thread.currentThread() + &quot; 我执行结束&quot;);
            } catch (InterruptedException e) {
            }
        }
    }
    
    //synchronized(static变量),synchronized(ObjectSyncDemo1.class),能同步,两个线程争抢的是同一把锁
    static Object temp = new Object();
    public void test1() {
		//synchronized (ObjectSyncDemo1.class) {
        synchronized (temp) {
            try {
                System.out.println(Thread.currentThread() + &quot; 我开始执行&quot;);
                Thread.sleep(3000L);
                System.out.println(Thread.currentThread() + &quot; 我执行结束&quot;);
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&gt; {
            new ObjectSyncDemo1().test1();
        }).start();

        Thread.sleep(1000L); // 等1秒钟,让前一个线程启动起来
        new Thread(() -&gt; {
            new ObjectSyncDemo1().test1();
        }).start();
    }
}
</code></pre>
<h3 id="可重入的代码示例">可重入的代码示例</h3>
<pre><code class="language-java">// 可重入
public class ObjectSyncDemo2 {

    public synchronized void test1(Object arg) {
        System.out.println(Thread.currentThread() + &quot; 我开始执行 &quot; + arg);
        if (arg == null) {
            test1(new Object());
        }
        System.out.println(Thread.currentThread() + &quot; 我执行结束&quot; + arg);
    }

    public static void main(String[] args) throws InterruptedException {
        new ObjectSyncDemo2().test1(null);
    }
}

</code></pre>
<h3 id="锁粗化的概念">锁粗化的概念</h3>
<p>https://www.oracle.com/java/technologies/javase/6performance.html#2.1.2</p>
<p>锁粗化是发生在编译器级别(JIT)的一种锁优化方式。</p>
<p>JVM会对热点代码(不间断、高频地)中的多个锁合并成一个锁,以降低短时间内大量锁请求、同步、释放带来的性能损耗。</p>
<p>注意：这样做是有前提的，就是中间不需要同步的代码能够很快速地完成，如果不需要同步的代码需要花很长时间，就会导致同步块的执行需要花费很长的时间，这样做也就不合理了。</p>
<pre><code class="language-java">// 锁粗化(运行时 jit 编译优化)
// jit 编译后的汇编内容, jitwatch可视化工具进行查看,修改优化级 别为C2
public class ObjectSyncDemo3 {
    int i;

    public void test1(Object arg) {
        synchronized (this) {
            i++;
        }
        synchronized (this) {
            i++;
        }
        //jvm会对热点代码进行优化,变成下面这样
        /*
        synchronized (this) {
            i++;
            i++;
        }*/
    }

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &lt; 10000000; i++) {
            new ObjectSyncDemo3().test1(&quot;a&quot;);
        }
    }
}

</code></pre>
<h3 id="锁消除的概念">锁消除的概念</h3>
<p>锁消除是发生在编译器级别(JIT)的一种锁优化方式。</p>
<p>有时候我们写的代码完全不需要加锁，却执行了加锁操作。</p>
<p>比如StringBuffer类的append操作,方法内部是加锁的,所以在执行一系列的append操作时JVM就会在保证线程安全的情况下消除锁</p>
<pre><code class="language-java">// 锁消除(jit)
public class ObjectSyncDemo4 {
    public void test3(Object arg) {
        StringBuilder builder = new StringBuilder();
        builder.append(&quot;a&quot;);
        builder.append(arg);
        builder.append(&quot;c&quot;);
        System.out.println(arg.toString());
    }

    public void test2(Object arg) {
        String a = &quot;a&quot;;
        String c = &quot;c&quot;;
        System.out.println(a + arg + c);
    }


    public void test1(Object arg) {
        // jit 优化, 消除了锁
        StringBuffer stringBuffer = new StringBuffer();
        stringBuffer.append(&quot;a&quot;);
        stringBuffer.append(arg);
        stringBuffer.append(&quot;c&quot;);
        // System.out.println(stringBuffer.toString());
    }

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i &lt; 1000000; i++) {
            new ObjectSyncDemo4().test1(&quot;123&quot;);
        }
    }
}
</code></pre>
<h2 id="同步关键字加锁原理">同步关键字加锁原理</h2>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200827140333983.png" alt="image-20200827140333983" loading="lazy"></figure>
<p>HotSpot中,对象前面会有一个类指针和标题,储标识哈希码的标题字以及用于分代垃圾收集的年龄和标记位</p>
<blockquote>
<p>参考来源:</p>
<p>https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf</p>
<p>https://wiki.openjdk.java.net/display/HotSpot/Synchronization</p>
</blockquote>
<h3 id="cas轻量级加锁其实就是替换mark-word-的内容">CAS轻量级加锁其实就是替换mark word 的内容</h3>
<figure data-type="image" tabindex="4"><img src="https://static.sunjianbo.com/image-20200827155650779.png" alt="image-20200827155650779" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://static.sunjianbo.com/image-20200827155756686.png" alt="image-20200827155756686" loading="lazy"></figure>
<p>使用CAS修改mark word完毕,加锁成功。则mark word中的tag进入<code>00</code>状态(01=unlocked,00=Light-Weight locked,10=Heavy-weight locked)。</p>
<p>解锁的过程,则是一个逆向恢复 mark word的过程</p>
<h3 id="偏向锁到轻量级锁">偏向锁到轻量级锁</h3>
<p>默认情况下JVM锁会经历:偏向锁--&gt;轻量级锁--&gt;重量级锁这四个状态</p>
<figure data-type="image" tabindex="6"><img src="https://static.sunjianbo.com/image-20200827153255997.png" alt="image-20200827153255997" loading="lazy"></figure>
<p>偏向标记第一次有用,出现过争用后就没用了。<code>-XX: -UseBiasedLocking</code>禁用使用偏置锁定,<code>-XX:+UseBiasedLocking</code>设置启用偏向锁。</p>
<p>偏向锁,本质就是无锁,如果没有发生过任何多线程争抢锁的情况,JVM认为就是单线程,无需做同步</p>
<blockquote>
<p>JVM为了少千活:同步在JVM底层是有很多操作来实现的,如果是没有争用,就不需要去做同步操作</p>
</blockquote>
<figure data-type="image" tabindex="7"><img src="https://static.sunjianbo.com/image-20200827160155278.png" alt="image-20200827160155278" loading="lazy"></figure>
<h3 id="重量级锁-监视器monitor">重量级锁 - 监视器(monitor)</h3>
<p>修改mark word如果失败,会自旋CAS一定次数,该次数可以通过参数配置</p>
<p>超过次数,仍未抢到锁,则锁升级为重量级锁进入阻塞。</p>
<p>monitor也叫做管程,计算机操作系统原理中有提及类似概念。一个对象会有一个对应的monitor。</p>
<figure data-type="image" tabindex="8"><img src="https://static.sunjianbo.com/image-20200827161120818.png" alt="image-20200827161120818" loading="lazy"></figure>
<p>在虚拟机的源码中可以看到监视器的内容</p>
<h1 id="简单过一下lock锁相关">简单过一下Lock锁相关</h1>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lock</td>
<td>获取锁的方法,若锁被其他线程获取,则等待(阻塞)</td>
</tr>
<tr>
<td>lockInterruptibly</td>
<td>在锁的获取过程中可以中断当前线程</td>
</tr>
<tr>
<td>tryLock</td>
<td>尝试非阻塞地获取锁,立即返回</td>
</tr>
<tr>
<td>unlock</td>
<td>释放锁</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>根据Lock接口的源码注释,Lock接口的实现,具备和同步关键字同样的内存语义。</p>
</blockquote>
<h2 id="reentrantlock">ReentrantLock</h2>
<p>独享锁;支持公平锁、非公平锁两种模式;可重入锁;</p>
<p><code>ReentrantLock</code>在上锁时，会根据实例化时指定的策略去获取锁，默认为非公平锁。如果上锁成功，锁状态值+1(重入，最大次数为 <code>Integer.MAX_VALUE</code>)，并将锁持有者设置为当前线程实例。在 <code>Sync(AQS)</code> 内部维护了一个队列，存放了所有上锁失败的线程。公平锁在上锁前，会检查在自己前面是否还有其他线程等待，如果有就放弃竞争，继续等待。而非公平锁会抓住每个机会，不管是否前面是否还有其它线程等待，只顾上锁</p>
<p><code>ReetrantLock</code>在释放锁时，将状态计数器减一(重入)，当状态计数器为0时，锁可用。此时再从等待队列中寻找合适的线程唤醒，默认从队首开始，如果队列正在更新中，且未找到合适的线程，那么从队尾开始寻找。</p>
<h2 id="readwritelock">ReadWriteLock</h2>
<p>维护一对关联锁,一个用于只读操作,一个用于写入;读锁可以由多个读线程同时持有,写锁是排他的。</p>
<p>适合读取线程比写入线程多的场景,改进互斥锁的性能,</p>
<p>示例场景:缓存组件、集合的并发线程安全性改造。</p>
<p>写锁是线程独占,读锁是共享,所以写-&gt;读是升级。(读-&gt;写,是不能实现的)</p>
<h3 id="关于锁降级">关于锁降级</h3>
<p><code>锁降级</code>指的是写锁降级成为读锁。把持住当前拥有的写锁的同时,再获取到读锁,随后释放写锁的过程。</p>
<pre><code class="language-java">import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

// 缓存示例
public class CacheDataDemo {
    // 创建一个map用于缓存
    private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    private static ReadWriteLock rwl = new ReentrantReadWriteLock();

    public static void main(String[] args) {
        // 1 读取缓存里面的数据
        // cache.query()
        // 2 如果缓存没数据,则取数据库里面查询  database.query()
        // 3 查询完成之后,数据塞到塞到缓存里面 cache.put(data)
    }

    public Object get(String id) {
        Object value = null;
        // 首先开启读锁，从缓存中去取
        rwl.readLock().lock();
        try {
            if (map.get(id) == null) {
                // TODO database.query();  全部查询数据库 ,缓存雪崩
                // 必须释放读锁
                rwl.readLock().unlock();
                // 如果缓存中没有释放读锁，上写锁。如果不加锁，所有请求全部去查询数据库，就崩溃了
                rwl.writeLock().lock(); // 所有线程在此处等待  1000  1  999 (在同步代码里面再次检查是否缓存)
                try {
                    // 双重检查，防止已经有线程改变了当前的值，从而出现重复处理的情况
                    if (map.get(id) == null) {
                        // TODO value = ...如果缓存没有，就去数据库里面读取
                    }
                    rwl.readLock().lock(); // 加读锁降级写锁,这样就不会有其他线程能够改这个值，保证了数据一致性			
                } finally {
                    rwl.writeLock().unlock(); // 释放写锁@
                }
            }
            //TODO cache.query();锁降级就是为了在这里保持数据可见性,避免在前面释放写锁后数据被别的线程修改
            
        } finally {
            rwl.readLock().unlock();
        }
        return value;
    }
}
</code></pre>
<p>如果当前的线程<em>C</em>在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程<em>T</em>获取了写锁并修改了数据，那么<em>C</em>线程无法感知到数据已被修改，则数据出现错误。</p>
<p>如果遵循锁降级的步骤，线程<em>C</em>在释放写锁之前获取读锁，那么线程<em>T</em>在获取写锁时将被阻塞，直到线程<em>C</em>完成数据处理过程，释放读锁。</p>
<h2 id="condition">Condition</h2>
<p>用于替代wait/notify</p>
<p>Object中的 wait(), notify(), notifyAll()方法是和 synchronized配合使用的,可以唤醒一个或者全部(单个等待集)</p>
<p>Condition是需要与Lock配合使用的,<strong>提供多个等待集合,更精确的控制</strong>(底层是park/ unpark机制);</p>
<figure data-type="image" tabindex="9"><img src="https://static.sunjianbo.com/image-20200828160438102.png" alt="image-20200828160438102" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全以及原子操作]]></title>
        <id>https://www.sunjianbo.com/thread-safe-atomic/</id>
        <link href="https://www.sunjianbo.com/thread-safe-atomic/">
        </link>
        <updated>2020-08-25T07:45:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程安全概念">线程安全概念</h2>
<h3 id="竞态条件与临界区">竞态条件与临界区</h3>
<pre><code class="language-java">public class Demo{
    public int i=0;
    public void incr(){
        i++
    }
}
</code></pre>
<p>多个线程访问了相同的资源,向这些资源做了<strong>写操作</strong>时,对执行顺序有要求</p>
<p>临界区:incr方法內部就是临界区域,关键部分代码的多线程并发执行,会对执行结果产生影响。</p>
<p>竞态条件:可能发生在临界区域内的特殊条件。多线程执行incr方法中的i++关键代码时,就产生了竞态条件。</p>
<h2 id="一些情况是线程安全的">一些情况是线程安全的</h2>
<h3 id="资源不共享">资源不共享</h3>
<p>如果一段代码是线程安全的,则它不包含竞态条件。只有当多个线程更新共享资源时,才会发生竞态条件。</p>
<p>栈封闭时,不会在线程之间共享的变量,都是线程安全的。</p>
<p>局部对象引用本身不共享,但是引用的对象存储在共享堆中。如果方法內创建的对象,只是在方法中传递,并且不对其他线程可用,那么也是线程安全的。</p>
<pre><code class="language-java">//例子
public void someMethod(){
    LocalObject localObject = new LocalObject();
    localObject.callMethod();
    method2(localObject);
}
public void method2(LocalObject localObject{
	localObject.setValue(&quot;value&quot;);
}
</code></pre>
<blockquote>
<p>判定规则:如果创建、使用和处理资源,永远不会逃脱单个线程的控制,该资源的使用是线程安全的。</p>
</blockquote>
<h3 id="对象不可变">对象不可变</h3>
<p>创建不可变的共享对象来保证对象在线程间共享时不会被修改,从而实现线程安全。</p>
<p>实例被创建,value变量就不能再被修改,这就是不可变性。</p>
<pre><code class="language-java">//比如没有提供set方法的私有属性
public class Demo{
    private int value =0;
    public Demo(int value){
        this.value= value
    }
    public int getValue(){
        return this.value;
    }
}
</code></pre>
<h3 id="原子操作">原子操作</h3>
<h4 id="原子操作定义">原子操作定义</h4>
<p>原子操作可以是一个步骤,也可以是多个操作步骤,但是其顺序不可以被打乱,也不可以被切割而只执行其中的一部分(不可中断性)。</p>
<p><font color=red>将整个操作视作一个整体是原子性的核心特征。</font></p>
<p>最开始例子里面的i++就不是一个原子操作,她包含三步骤:</p>
<ol>
<li>加载i</li>
<li>计算+1</li>
<li>赋值i</li>
</ol>
<p>存在竞态条件的情况下,线程不安全,需要转变为原子操作才能安全。</p>
<h4 id="方式一-循环cas">方式一: 循环CAS</h4>
<h5 id="cas机制">CAS机制</h5>
<p><code>Compare and swap</code>比较和交换。属于硬件同步原语,处理器提供了基本内存操作的原子性保证。</p>
<p>CAS操作需要输入两个数值,一个旧值A(期望操作前的值)和一个新值B,在操作期间先比较下旧值有没有发生变化,如果没有发生变化,才交换成新值,发生了变化则不交换。(类似乐观锁)</p>
<p>JAVA中的 <code>sun.misc.Unsafe</code>类,提供了 <code>compareAndSwaplnt()</code>和 <code>compareAndSwapLong()</code>等几个方法实现CAS</p>
<pre><code class="language-java">package com.study.lock.lock;

import sun.misc.Unsafe;
import java.lang.reflect.Field;

public class LockDemo1 {
    volatile int value = 0;

    static Unsafe unsafe; // 直接操作内存，修改对象，数组内存....强大的API
    private static long valueOffset;

    static {
        try {
            // 反射技术获取unsafe值
            Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            field.setAccessible(true);
            unsafe = (Unsafe) field.get(null);

            // 获取到 value 属性偏移量（用于定位value属性在内存中的具体地址）
            valueOffset = unsafe.objectFieldOffset(LockDemo1.class
                    .getDeclaredField(&quot;value&quot;));

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public void add() {
        // TODO xx00
        // i++;// JAVA 层面三个步骤
        // CAS + 循环 重试
        int current;
        do {
            // 操作耗时的话， 那么 线程就会占用大量的CPU执行时间
            current = unsafe.getIntVolatile(this, valueOffset);
        } while (!unsafe.compareAndSwapInt(this, valueOffset, current, current + 1));
        // 因为跨平台的问题,而我们是用反射的非正常方式获得unsafe,所以可能会失败
    }

    public static void main(String[] args) throws InterruptedException {
        LockDemo1 ld = new LockDemo1();

        for (int i = 0; i &lt; 2; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 10000; j++) {
                    ld.add();
                }
            }).start();
        }
        Thread.sleep(2000L);
        System.out.println(ld.value);
    }
}
</code></pre>
<blockquote>
<p>其实AtomicInteger这些封装类的底层就是这么写的</p>
</blockquote>
<h5 id="javautilconcurrent包内的原子操作封装类">java.util.concurrent包内的原子操作封装类</h5>
<ul>
<li>
<p>AtomicBoolean:原子更新布尔类型</p>
</li>
<li>
<p>AtomicInteger:原子更新整型</p>
</li>
<li>
<p>AtomicLong:原子更新长整型</p>
</li>
<li>
<p>AtomicIntegerArray:原子更新整型数组里的元素</p>
</li>
<li>
<p>AtomicLongArray:原子更新长整型数组里的元素</p>
</li>
<li>
<p>AtomicReferenceArray:原子更新引用类型数组里的元素</p>
</li>
<li>
<p>AtomiclntegerFieldUpdater:原子更新整型的字段的更新器</p>
</li>
<li>
<p>AtomicLongFieldUpdater:原子更新长整型字段的更新器</p>
</li>
<li>
<p>AtomicReferenceFieldUpdater:原子更新引用类型里的字段</p>
</li>
<li>
<p>AtomicReference:原子更新引用类型</p>
</li>
<li>
<p>AtomicStampedReference:原子更新带有版本号的引用类型</p>
</li>
<li>
<p>AtomicMarkableReference:原子更新带有标记位的引用类型。</p>
<p>jdk1.8更新</p>
</li>
<li>
<p>更新器: DoubleAccumulator、 LongAccumulator</p>
</li>
<li>
<p>计数器: DoubleAdder、 LongAdder(一个使用场景是统计接口调用次数时可使用)</p>
</li>
</ul>
<blockquote>
<p>计数器增强版,高并发下性能更好</p>
<p>频繁更新但不太频繁读取的汇总统计信息时使用</p>
<p>分成多个操作单元,不同线程更新不同的单元只有需要汇总的时候才计算所有单元的操作</p>
</blockquote>
<blockquote>
<p>即分成多个值(Cell)减少竞争,对外暴露一个虚拟值,最后取得时候使用sum()把多个内存块的Cell相加</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200825135731552.png" alt="image-20200825135731552" loading="lazy"></figure>
</blockquote>
<h5 id="三个缺点">三个缺点:</h5>
<ol>
<li>循环+CAS,自旋的实现让所有线程都处于高频运行,争抢CPU执行时间的状态。如果操作长时间不成功,会带来很大的cPU资源消耗。</li>
<li>仅针对单个变量的操作,不能用于多个变量来实现原子操作。即很长的代码没法用CAS</li>
<li>ABA问题。(详情查看:<a href="https://www.sunjianbo.com/cas-aba/">https://www.sunjianbo.com/cas-aba/</a>)。</li>
</ol>
<h4 id="方式二-锁">方式二: 锁</h4>
<p>锁能保证可见性,是基于Happens-before原则</p>
<p>一个线程的unlock一定执行在另一个线程的lock前面,也就是说另一个线程不会插进该线程的执行过程(lock-&gt;op-&gt;unlock)中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java CAS ABA问题发生的场景分析(转)]]></title>
        <id>https://www.sunjianbo.com/cas-aba/</id>
        <link href="https://www.sunjianbo.com/cas-aba/">
        </link>
        <updated>2020-08-25T07:23:23.000Z</updated>
        <content type="html"><![CDATA[<p>原文转自:<a href="https://www.cnblogs.com/senlinyang/p/7875381.html">https://www.cnblogs.com/senlinyang/p/7875381.html</a></p>
<p>CAS操作存在一个ABA问题，就是在CAS之前A变成B又变回A，CAS还是能够设置成功的，</p>
<p>什么场景下会出现这个问题呢？查了一些资料，发现在下面的两种情况下会出现ABA问题。</p>
<h2 id="1-a最开始的内存地址是x然后失效了有分配了b恰好内存地址是x这时候通过cas操作却设置成功了">1. A最开始的内存地址是X，然后失效了，有分配了B，恰好内存地址是X，这时候通过CAS操作，却设置成功了</h2>
<p>这种情况在带有GC的语言中，这种情况是不可能发生的，为什么呢？</p>
<p>拿JAVA举例，在执行CAS操作时，A，B对象肯定生命周期内，GC不可能将其释放，那么A指向的内存是不会被释放的，B也就不可能分配到与A相同的内存地址，CAS失败。若在无GC的，A对象已经被释放了，那么B被分配了A的内存，CAS成功。</p>
<h2 id="2-线程1准备用cas将变量的值由a替换为b在此之前线程2将变量的值由a替换为c又由c替换为a然后线程1执行cas时发现变量的值仍然为a所以cas成功">2. 线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。</h2>
<p>但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题。</p>
<p>比如：现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：head.compareAndSet(A,B);在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A。而对象B此时处于游离状态：此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，其中堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。</p>
<p>以上就是由于ABA问题带来的隐患，各种乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题</p>
<p>在Java中，<code>AtomicStampedReference&lt;E&gt;</code>也实现了这个作用，它通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题，</p>
<p>例如下面的代码分别用AtomicInteger和AtomicStampedReference来对初始值为100的原子整型变量进行更新，AtomicInteger会成功执行CAS操作，而加上版本戳的AtomicStampedReference对于ABA问题会执行CAS失败</p>
<pre><code class="language-java">package concur.lock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicStampedReference;

public class ABA {
    
    private static AtomicInteger atomicInt = new AtomicInteger(100);
    private static AtomicStampedReference&lt;Integer&gt; atomicStampedRef = 
            new AtomicStampedReference&lt;Integer&gt;(100, 0);
    
    public static void main(String[] args) throws InterruptedException {
        Thread intT1 = new Thread(new Runnable() {
            @Override
            public void run() {
                atomicInt.compareAndSet(100, 101);
                atomicInt.compareAndSet(101, 100);
            }
        });
        
        Thread intT2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                boolean c3 = atomicInt.compareAndSet(100, 101);
                System.out.println(c3);        //true
            }
        });
        
        intT1.start();
        intT2.start();
        intT1.join();
        intT2.join();
        
        Thread refT1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                atomicStampedRef.compareAndSet(100, 101, 
                        atomicStampedRef.getStamp(), atomicStampedRef.getStamp()+1);
                atomicStampedRef.compareAndSet(101, 100, 
                        atomicStampedRef.getStamp(), atomicStampedRef.getStamp()+1);
            }
        });
        
        Thread refT2 = new Thread(new Runnable() {
            @Override
            public void run() {
                int stamp = atomicStampedRef.getStamp();
                System.out.println(&quot;before sleep : stamp = &quot; + stamp);    // stamp = 0
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;after sleep : stamp = &quot; + atomicStampedRef.getStamp());//stamp = 1
                boolean c3 = atomicStampedRef.compareAndSet(100, 101, stamp, stamp+1);
                System.out.println(c3);        //false
            }
        });
        
        refT1.start();
        refT2.start();
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用gitlab的webhook实现合并分支时在jira上打个标签的功能]]></title>
        <id>https://www.sunjianbo.com/webhook-jira/</id>
        <link href="https://www.sunjianbo.com/webhook-jira/">
        </link>
        <updated>2020-08-21T01:41:30.000Z</updated>
        <content type="html"><![CDATA[<p>公司通过gitlab托管代码,采用jira作为敏捷实践的管理工具,每次发布的时候拉出当前迭代的所有故事做发布计划.</p>
<p>然而实际上因为某些原因,基本上无法实现每次迭代的所有故事都能发布.只有在分支上测试完成合并到 master上的故事才会被发布.</p>
<p>那么就想着能不能在分支合并到master的时候在jira上打个标签,这样在jira上一筛选就知道哪些故事是可以发布的了</p>
<p>好在gitlab有webhook功能,能够在触发某些操作的时候调用自定义的接口传输相关操作的信息,而jira也提供了相应的api来方便读写,那么只需要发布一个服务提供接口给webhook调用,解析传过来的参数,符合条件的情况下去调用jira的api修改标签,这个方案也就实现了.</p>
<h2 id="本文相关版本信息">本文相关版本信息</h2>
<blockquote>
<p>GitLab Community Edition 11.1.4</p>
<p>JIRA v7.13.5</p>
<p>python 3.5.4</p>
<p>Flask 1.1.2</p>
<p>requests 2.24.0</p>
</blockquote>
<h2 id="提前约定">提前约定</h2>
<p>在git创建分支时分支名称需要包含jiraId</p>
<p>我们项目组是直接以jiraId+故事标题命名分支</p>
<h2 id="编写程序">编写程序</h2>
<p>图快速方便所以用python写的,结果后面部署费了不少事</p>
<h3 id="webhook调用接口传递参数解析">webhook调用接口传递参数解析</h3>
<p>文档: https://docs.gitlab.com/ee/user/project/integrations/webhooks.html</p>
<p>参数是json形式的</p>
<p>主要取出其中3个参数</p>
<ul>
<li>
<p>object_attributes.state</p>
<p>gitlab设置的trigger是合并事件,实际上会在申请(opened),关闭(closed)和完成合并(merged)3个情况触发,所以要判断是否是完成合并的调用</p>
</li>
<li>
<p>object_attributes.target_branch</p>
<p>target_branch 是为了确认是合并到master的请求,合并到其他分支的请求不处理</p>
</li>
<li>
<p>object_attributes. source_branch</p>
<p>source_branch 是为了取出jiraId以进行后续操作</p>
</li>
</ul>
<h3 id="jira接口调用">jira接口调用</h3>
<p>文档: https://developer.atlassian.com/server/jira/platform/jira-rest-api-examples/#editing-an-issue-examples</p>
<p>从source_branch利用正则截取出jiraId,拼装并调用接口地址</p>
<p>附三个修改标签的传参,第一个是追加,后两种是覆盖设置</p>
<pre><code>#增加
{
    &quot;update&quot; : {
        &quot;labels&quot; : [{&quot;add&quot; : &quot;标签内容&quot;}]
    }
}
#设置
{
    &quot;fields&quot; : {
        &quot;labels&quot;: [&quot;标签内容&quot;]
        
        
    }
}
{
    &quot;update&quot; : {
        &quot;labels&quot; : [{&quot;set&quot; : [&quot;标签内容&quot;]}]
    }
}
</code></pre>
<h4 id="ps">PS:</h4>
<p>建议先用postman之类的工具先调试一下jira的接口,如果报错</p>
<blockquote>
<p>Field 'labels' cannot be set. It is not on the appropriate screen, or unknown.</p>
</blockquote>
<p>那就需要联系jira管理员,在项目的screens(项目管理-&gt;界面)中开启相关字段的api读写权限</p>
<h3 id="完整源码如下">完整源码如下:</h3>
<pre><code class="language-python"># -*- coding: utf-8 -*-

from flask import Flask,request
import requests
import re

baseUrl = 'http://jira.sunjianbo.com:8080/rest/api/2/issue/'
app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def test():
    # addTag2Jira(&quot;DB19236-2398 324扥矿赛肯&quot;)
    return &quot;hello world&quot;

@app.route(&quot;/merged&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def merged():
    # print(request.headers)
    # print(request.json)
    # print('---')
    body = request.json
    object_attributes = body['object_attributes']
    state = object_attributes['state']  # opened,closed,merged
    source_branch = object_attributes['source_branch']
    target_branch = object_attributes['target_branch']
    if state == 'merged' and target_branch == 'master':
        # 已合并到master
        print('是已合并到master的请求,开始修改jira标签')
        addTag2Jira(source_branch)
    else:
        print('不是合并到master的成功请求,而是合并到['+target_branch+']的['+state+&quot;]请求&quot;)
    return &quot;&quot;

def addTag2Jira(source_branch):
    # 取得分支jira id
    matchObj = re.search(r&quot;DB\d+-\d+&quot;, source_branch)
    if matchObj:
        print(&quot;匹配出的jiraId: &quot;, matchObj.group())
        jiraId = matchObj.group()
        # 去相应jira故事中打一个uat标签
        url = baseUrl + jiraId
        messagebody = '''
            {
                &quot;update&quot; : {
                    &quot;labels&quot; : [{&quot;add&quot; : &quot;UAT&quot;}]
                }
            }
            '''
        result = fun_put(url, messagebody)
        print(result)
        if result.status_code == 204:
            print('修改成功: ' + url)
        else:
            print('修改失败: ' + source_branch)
    else:
        print(&quot;分支名称上找不到jiraId: &quot; + source_branch)

def fun_put(url, messagebody):
    headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
    r = requests.put(url, data=messagebody, headers=headers, auth=('username', 'passwd'))
    print(r.status_code)
    return r

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, port=8080)
</code></pre>
<h2 id="部署">部署</h2>
<p>部署这里有个插曲</p>
<p>公司服务器是离线的,所以我先离线安装了python3,然后打算安装virtualenv时报了一个ssl的错误,明明是离线安装,为毛会涉及到ssl,咱也不知道,咱也不敢问,推测是python3安装的有点问题,依赖的openssl之类的在测试机上不太全吧</p>
<p>折腾了半天没搞定,考虑到是测试服务器我就瞎搞了一把</p>
<p>用了</p>
<pre><code>pip3 install -r requirements.txt --proxy=代理服务器IP:端口号
</code></pre>
<p>代理走了我本地电脑在线安装了Flask和 requests,瞬间就解决了(给机智的我点个赞(◔◡◔))</p>
<h2 id="设置gitlab上的webhook">设置gitlab上的webhook</h2>
<p>settings-&gt;integrations-&gt;填写url-&gt;Trigger勾选<code>Merge request events</code>-&gt;嫌麻烦我禁用了ssl,没有实际测试一下行不行-&gt;保存</p>
<p><img src="https://static.sunjianbo.com/image-20200820160206463.png" alt="set-integrations" loading="lazy">)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存模型(理论很枯燥)]]></title>
        <id>https://www.sunjianbo.com/jmm/</id>
        <link href="https://www.sunjianbo.com/jmm/">
        </link>
        <updated>2020-08-20T07:52:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="多线程中的问题">多线程中的问题</h2>
<ol>
<li>所见非所得</li>
<li>无法肉眼去检测程序的准确性</li>
<li>不同的运行平台有不同的表现</li>
<li>错误很难重现</li>
</ol>
<h2 id="问题示例">问题示例</h2>
<p>将运行模式设置为-server， 变成死循环   。 没加默认就是client模式，就是正常（可见性问题）</p>
<pre><code class="language-java">import java.util.concurrent.TimeUnit;

// 1、 jre/bin/server  放置hsdis动态链接库
//  测试代码 将运行模式设置为-server， 变成死循环   。 没加默认就是client模式，就是正常（可见性问题）
// 2、 通过设置JVM的参数，打印出jit编译的内容 （这里说的编译非class文件），通过可视化工具jitwatch进行查看
// -server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log
//  关闭jit优化-Djava.compiler=NONE
public class VisibilityDemo {
    private volatile boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        VisibilityDemo demo1 = new VisibilityDemo();
        Thread thread1 = new Thread(new Runnable() {
            public void run() {
                int i = 0;
                // class -&gt;  运行时jit编译  -&gt; 汇编指令 -&gt; 重排序
                while (demo1.flag) { // 指令重排序
                    i++;
                }
                System.out.println(i);
            }
        });
        thread1.start();

        TimeUnit.SECONDS.sleep(2);
        // 设置is为false，使上面的线程结束while循环
        demo1.flag = false;
        System.out.println(&quot;被置为false了.&quot;);
    }
}
</code></pre>
<h3 id="死循环可能的两个原因">死循环可能的两个原因:</h3>
<h4 id="cpu缓存">CPU缓存</h4>
<p>​	CPU缓存在这里会导致线程读取的flag延迟一些变为false,但不会发生死循环</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200813093851143.png" alt="工作内存缓存" loading="lazy"></figure>
<h4 id="指令重排序">指令重排序</h4>
<p>Java编程语言的语义允许**编译器和微处理器(JIT)**执行优化,这些优化可以与不正确的同步代码交互,从而产生看似矛盾的行为。</p>
<ol>
<li>执行顺序的重排序</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200813094122201.png" alt="image-20200813094122201" loading="lazy"></figure>
<ol start="2">
<li>等效替换的重排序</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200813094209877.png" alt="image-20200813094209877" loading="lazy"></figure>
<p>虽然有as-if- serial的原则,但是因为多CPU的情况就变得复杂了,每个cpu只能保证自己的重排序是没有问题的</p>
<h3 id="真正原因">真正原因</h3>
<p>汇编层面的重排序会将<code>while(demo1.flag)</code>变为</p>
<pre><code> if(demo1.flag){
     while(true){
         i++
     }
 }
</code></pre>
<p>它认为demo1.flag基本不变就是true</p>
<h3 id="附-jitwatch使用">附: JITWatch使用</h3>
<p>可直接参考这个操作博客<br>
http://www.cnblogs.com/stevenczp/p/7975776.html<br>
https://www.cnblogs.com/stevenczp/p/7978554.html</p>
<ol>
<li>
<p>输出jit日志</p>
<ol>
<li>（windows）在jre/bin/server  放置hsdis动态链接库</li>
<li>eclise、idea等工具，加上JVM参数<br>
-server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log</li>
</ol>
</li>
<li>
<p>工具安装<br>
下载  https://github.com/AdoptOpenJDK/jitwatch</p>
</li>
<li>
<p>解压 通过maven运行</p>
</li>
</ol>
<pre><code>mvn clean compile exec:java
</code></pre>
<ol start="4">
<li>
<p>配置jitwatch<br>
页面选择 config， 配置要调试的项目src源码路径，和class编译路径<br>
打开jit.log<br>
点击start</p>
</li>
<li>
<p>在分析的结果中，选中指定的类，再选择右侧的具体方法，则弹出jit编译结果</p>
</li>
</ol>
<hr>
<p>为了解决多线程的问题,提出了一种规范,就是内存模型</p>
<h2 id="内存模型memory-model的定义">内存模型(Memory Model)的定义</h2>
<p>内存模型描述程序的可能行为。</p>
<p><strong>Java编程语言内存模型</strong>通过检查执行跟踪中的每个读操作,并根据某些规则检查该读操作观察到的写操作是否有效来工作。</p>
<p>要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现,包括操作的重新排序和删除不必要的同步。</p>
<blockquote>
<p>内存模型决定了在程序的每个点上可以读取什么值</p>
<p>比如说线程1的操作让线程2能及时看到改变,也就是说在这个点上线程2可以且必须读到它应该读取的正确的值</p>
</blockquote>
<h3 id="shared-variables共享变量">Shared variables共享变量</h3>
<p>描述可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段、静态字段和数组元素都存储在堆内存中。</p>
<p>如果至少有一个访问是写的,那么对同一个变量的两次访问(读或写)是冲突的。</p>
<p>这句话定义在:https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jis-17.4.1</p>
<h3 id="线程间操作的定义">线程间操作的定义</h3>
<ul>
<li>write要写的变量以及要写的值。</li>
<li>read要读的变量以及可见的写入值(由此,我们可以确定可见的值)</li>
<li>lock要锁定的管程(监视器 monitor)</li>
<li>unlock要解锁的管程。</li>
<li>外部操作(socket等等..)</li>
<li>启动和终止</li>
</ul>
<p>程序顺序: 如果一个程序没有数据竞争,那么程序的所有执行看起来都是顺序一致的</p>
<p>本规范只涉及线程间的操作</p>
<h3 id="对于同步的规则定义">对于同步的规则定义</h3>
<p><em>同步我理解就是对一些操作约定了固定的先后顺序,且后面能看到前面的操作</em></p>
<ul>
<li>对于监视器m的解锁与所有后续操作对于m的加锁同步</li>
<li>对 volatile变量v的写入,与所有其他线程后续对v的读同步</li>
<li>启动线程的操作与线程中的第一个操作同步</li>
<li>对于每个属性写入默认值(0, false,null)与每个线程对其进行的操作同步</li>
<li>线程T1的最后操作与线程T2发现线程T1已经结束同步(isAlive, join可以判断线程是否终结)</li>
<li>如果线程T1中断了T2,那么线程T1的中断操作与其他所有线程发现T2被中断了同步(通过抛出InterruptedException异常,或者调用Thread.interrupted或Thread.isInterrupted)</li>
</ul>
<h3 id="happens-before先行发生原则">Happens- before先行发生原则</h3>
<p>happens-before关系主要用于强调两个有冲突的动作之间的顺序,以及定义数据争用的发生时机。</p>
<p>具体的虚拟机实现,有必要确保以下原则的成立</p>
<ul>
<li>某个线程中的每个动作都 happens-before该线程中该动作后面的动作</li>
<li>某个管程上的 unlock动作 happens-before同一个管程上后续的lock动作</li>
<li>对某个 volatile字段的写操作 happens-before每个后续对该 volatile字段的读操作</li>
<li>在某个线程对象上调用 start()方法 happens-before该启动了的线程中的任意动作</li>
<li>某个线程中的所有动作 happens-before任意其它线程成功从该线程对象上的join()中返回</li>
<li>如果某个动作a happens-before动作b,且b happens-before动作c,则有 a happens-before c</li>
</ul>
<p>当程序包含两个没有被 happens-before关系排序的冲突访问时,就称存在<strong>数据争用</strong></p>
<p>遵守了这个原则,也就意味着有些代码不能进行重排序,有些数据不能缓存!</p>
<h2 id="一些实践">一些实践</h2>
<h3 id="volatile关键字">volatile关键字</h3>
<p>可见性问题:让一个线程对共享变量的修改,能够及时的被其他线程看到。</p>
<blockquote>
<p>根据JMM中规定的 happen before和同步原则:</p>
<p>对某个 volatile字段的写操作 happens-before每个后续对该 volatile字段的读操作。</p>
<p>对 volatile变量v的写入,与所有其他线程后续对v的读同步</p>
</blockquote>
<p>要满足这些条件,所以 volatile关键字就有这些功能:</p>
<ol>
<li>
<p>禁止缓存:</p>
<p>volatile变量的访问控制符会加个 ACC VOLATILE</p>
<p>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#tjvms-4.5</p>
</li>
<li>
<p>对 volatile变量相关的指令不做重排序</p>
</li>
</ol>
<h3 id="fina在jmm中的处理">fina在JMM中的处理</h3>
<ul>
<li>final在该对象的构造函数中设置对象的字段,当线程看到该对象时,将始终看到该对象的final字段的正确构造版本。<br>
伪代码示例: <code>f= new finalDemo();</code>读取到的f.x一定最新,x为final字段。而y可能是0</li>
</ul>
<pre><code class="language-java">// 官方示例，可能会读取到y的值为0
class FinalFieldExample {
    final int x;
    int y;
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3;
        y = 4;
    }

    static void writer() {
        f = new FinalFieldExample();
    }

    static void reader() {
        if (f != null) {
            int i = f.x;  // guaranteed to see 3 肯定是3
            int j = f.y;  // could see 0 可能看到0
        }
    }
}
</code></pre>
<ul>
<li>
<p>如果在构造函数中设置字段后发生读取,则会看到该final字段分配的值,否则它将看到默认值;<br>
伪代码示例: <code>public finalDemo(){x=1;y=x;};</code>y会等于1;</p>
</li>
<li>
<p>读取该共享对象的final成员变量之前,先要读取共享对象。<br>
伪代码示例:<code>r = new ReferenceObj();k=r.f;</code>这两个操作不能重排序</p>
</li>
<li>
<p>通常<code>static final</code>是不可以修改的字段。然而<code>System.in</code>,<code>System.out</code>和 <code>System.err</code>是 <code>static final</code>字段,遗留原因,必须允许通过set方法改变,我们将这些字段称为写保护,以区别于普通final字段;</p>
</li>
</ul>
<h3 id="word-tearing字节处理">Word Tearing字节处理</h3>
<p>一个字段或元素的更新不得与任何其他字段或元素的读取或更新交互。</p>
<p>特别是,分别更新字节数组的相邻元素的两个线程不得干涉或交互,也不需要同步以确保顺序一致性。</p>
<p>有些处理器(尤其是早期的Alphas处理器)没有提供写单个字节的功能</p>
<p>在这样的处理器上更新byte数组,若只是简单地读取整个内容,更新对应的字节,然后将整个内容再写回内存,将是不合法的。</p>
<p>这个问题有时候被称为**“字分裂 word tearing)”**,在单独更新单个字节有难度的处理器上,就需要寻求其它方式了。</p>
<p>基本不需要考虑这个,了解就好。</p>
<pre><code class="language-java">// https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4
// 官方提供的示例，检查有没有WordTearing情况
public class WordTearing extends Thread {
    static final int LENGTH = 8;
    static final int ITERS = 1000000;
    static byte[] counts = new byte[LENGTH];
    static Thread[] threads = new Thread[LENGTH];

    final int id;

    WordTearing(int i) {
        id = i;
    }

    public void run() {
        byte v = 0;
        for (int i = 0; i &lt; ITERS; i++) {
            byte v2 = counts[id];
            if (v != v2) {
                System.err.println(&quot;Word-Tearing found: &quot; +
                        &quot;counts[&quot; + id + &quot;] = &quot; + v2 +
                        &quot;, should be &quot; + v);
                return;
            }
            v++;
            counts[id] = v;
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; LENGTH; ++i)
            (threads[i] = new WordTearing(i)).start();
    }
}
</code></pre>
<h3 id="double和long的特殊处理">double和long的特殊处理</h3>
<p>虚拟机规范中,写64位的 double和long分成了两次32位值的操作</p>
<p>由于不是原子操作,可能导致读取到某次写操作中64位的前32位,以及另外一次写操作的后32位</p>
<figure data-type="image" tabindex="4"><img src="https://static.sunjianbo.com/image-20200814163308291.png" alt="image-20200814163308291" loading="lazy"></figure>
<p>读写 volatile的long和 double总是原子的。读写引用也总是原子的</p>
<blockquote>
<p>商业JⅥM不会存在这个问题,虽然规范没要求实现原子性,但是考虑到实际应用,大部分都实现了原子性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池应用及实现原理剖析]]></title>
        <id>https://www.sunjianbo.com/thread-pool/</id>
        <link href="https://www.sunjianbo.com/thread-pool/">
        </link>
        <updated>2020-08-17T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="为什么要用线程池">为什么要用线程池</h2>
<p>线程是不是越多越好?</p>
<ol>
<li>线程在java中是一个对象,更是操作系统的资源,线程创建、销毁需要时间。如果创建时间+销毁时间&gt;执行任务时间就很不合算。</li>
<li>java对象占用堆内存,操作系统线程占用系统内存,根据jνm规范,一个线程默认最大栈大小1M,这个栈空间是需要从系统内存中分配的。线程过多,会消耗很多的內存。</li>
<li>操作系统需要频繁切换线程上下文(大家都想被运行),影响性能。</li>
</ol>
<p>线程池的推出,就是为了方便的控制线程数量。</p>
<h2 id="线程池原理-概念">线程池原理 - 概念</h2>
<h4 id="线程池管理器">线程池管理器</h4>
<p>用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务;</p>
<h4 id="工作线程">工作线程</h4>
<p>线程池中线程,在没有任务时处于等待状态,可以循环的执行任务;</p>
<h4 id="任务接口">任务接口</h4>
<p>每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行完后的收尾工作,任务的执行状态等;</p>
<h4 id="任务队列">任务队列</h4>
<p>用于存放没有处理的任务。提供一种缓冲机制。</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200805095038062.png" alt="" loading="lazy"></figure>
<h2 id="线程池api-接口定义和实现类">线程池API - 接口定义和实现类</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td>Executor</td>
<td>最上层的接口,定义了<font color=red>执行任务的方法 execute</font></td>
</tr>
<tr>
<td>接口</td>
<td>ExecutorService</td>
<td>继承了 Executor接口,拓展了 Callable、 Future、关闭方法</td>
</tr>
<tr>
<td>接口</td>
<td>ScheduledExecutorService</td>
<td>继承了 ExecutorService,增加了定时任务相关的方法</td>
</tr>
<tr>
<td>实现类</td>
<td>ThreadPoolExecutor</td>
<td><font color=red>基础、标准的线程池实现</font></td>
</tr>
<tr>
<td>实现类</td>
<td>ScheduledThreadPoolExecutor</td>
<td>继承了 ThreadPoolExecutor,实现了ScheduledExecutorService中相关<font color=red>定时任务</font>的方法</td>
</tr>
</tbody>
</table>
<h2 id="线程池api-方法定义">线程池API - 方法定义</h2>
<h3 id="executorservice">ExecutorService</h3>
<pre><code class="language-java">//监测ExecutorService是否已经关闭， 直到所有任务完成执行，或超时发生，或当前线程被中断
awaitTermination(long timeout, TimeUnit unit)
//执行给定的任务集合，执行完毕后，返回结果
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务集合，执行完毕或者超时后，返回结果，其他任务终止
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//执行给定的任务，任意一个执行成功则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务，任意一个执行成功或者超时后，则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//如果此线程池已关闭，则返回true。
isShutdown()
//如果关闭后所有任务都已完成，则返回true。
isTerminated()
//优雅关闭线程池，之前提交的任务将被执行，但是不会接受新的任务。
shutdown()
//尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行任务的列表。
shutdownNow()
//提交个用于执行的Callable返回任务，并返回一个Future,用于获取Callable执行结果
submit(Callable&lt;T&gt; task)
//提交可运行任务以执行，并发回一个Future对象，执行结果为null
submit(Runnable task)
//提交可运行任务以执行，并返回Future, 执行结果为传入的result
submit(Runnable task, T result)
</code></pre>
<h3 id="scheduledexecutorservice">ScheduledExecutorService</h3>
<ul>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务过了给定的初始延迟时间,会第一次被执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会等到该次任务执行结束后,立刻执行,这也是它和<code>scheduleWithFixedDelay</code>的重要区别。<br>
此处结合代码示例进行理解即可!</p>
</li>
<li>
<p><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务,过了初始延迟时间,第一次被执行,后续以给定的周期时间执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会在该次任务执行结束的时间基础上,计算执行延时。</p>
<p>对于超过周期的长时间处理任务的不同处理方式,这是它和<code>scheduleAtFixedRate</code>的重要区别。</p>
</li>
</ul>
<h2 id="线程池api-executors工具类">线程池API - Executors工具类</h2>
<p>你可以自己实例化线程池,也可以用 Executors创建线程池的工厂类,常用方法如下:</p>
<h3 id="newfixedthreadpoolint-nthreads">newFixedThreadPool(int nThreads)</h3>
<p>创建一个固定大小、任务队列容量无界的线程池。核心线程数=最大线程数。</p>
<h3 id="newcachedthreadpool">newCachedThreadPool()</h3>
<p>创建的是一个大小无界的缓冲线程池。它的任务队列是一个同步队列。</p>
<p>任务加入到池中,如果池中有空闲线程,则用空闲线程执行,如无则创建新线程执行。</p>
<p>池中的线程空闲超过60秒,将被销毁释放。线程数随任务的多少变化。</p>
<p>适用于执行耗时较小的异步任务。池的核心线程数=0,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h3 id="newsinglethreadexecutor">newSingleThreadExecutor()</h3>
<p>只有一个线程来执行无界任务队列的单一线程池。</p>
<p>该线程池确保任务按加入的顺序一个个依次执行。当唯一的线程因任务异常中止时,将创建一个新的线程来继续执行后续的任务。</p>
<p>与 <code>newFixedThreadPool(1)</code>的区别在于,单一线程池的池大小在<code>newSingleThreadExecutor</code>方法中硬编码,不能再改变的。</p>
<h3 id="newscheduledthreadpoolint-corepoolsize">newScheduledThreadPool(int corePoolSize)</h3>
<p>能定时执行任务的线程池。该池的核心线程数由参数指定,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h2 id="线程池原理-任务execute过程">线程池原理-任务execute过程</h2>
<ol>
<li>
<p>是否达到核心线程数量?</p>
<p>没达到,创建一个工作线程来执行任务。</p>
</li>
<li>
<p>工作队列是否已满?</p>
<p>没满,则将新提交的任务存储在工作队列里。</p>
</li>
<li>
<p>是否达到线程池最大数量?</p>
<p>没达到,则创建一个新的工作线程来执行任务。</p>
</li>
<li>
<p>最后,执行拒绝策略来处理这个任务。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200806112820086.png" alt="" loading="lazy"></figure>
<h2 id="实践-合适的线程数量">实践 - 合适的线程数量</h2>
<p>如何确定合适数量的线程?</p>
<ul>
<li>
<p>计算型任务:</p>
<p>CPU数量的1-2倍</p>
</li>
<li>
<p>IO型任务:</p>
<p>相对比计算型任务,需多一些线程,要根据具体的<u>IO阻塞时长</u>进行考量决定。<br>
如 tomcat中默认的最大线程数为: 200。</p>
</li>
</ul>
<p>也可考虑根据需要在一个<u>最小数量和最大数量间</u>自动增减线程数。(<code>newCachedThreadPool</code>)</p>
<h2 id="代码示例">代码示例:</h2>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/** 线程池的使用 */
public class Demo9 {

	/**
	 * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况
	 * 
	 * @param threadPoolExecutor 传入不同的线程池，看不同的结果
	 * @throws Exception
	 */
	public void testCommon(ThreadPoolExecutor threadPoolExecutor) throws Exception {
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 查看线程数量，查看队列等待数量
		Thread.sleep(500L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
		// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）
		Thread.sleep(15000L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
	}

	/**
	 * 标准线程池
	 * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest1() throws Exception {
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());

		testCommon(threadPoolExecutor);
		// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 有拒绝策略的
	 * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest2() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 5个任务直接分配线程开始执行
		// 2、 3个任务进入等待队列
		// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)
		// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。
		// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程
	}

	/**
	 * 自定义Executors.newFixedThreadPool(int nThreads)
	 * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest3() throws Exception {
		// 和Executors.newFixedThreadPool(int nThreads)一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 自定义Executors.newCachedThreadPool()
	 * 4、 线程池信息：
	 * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest4() throws Exception {

		// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。
		// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，
		// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，
		// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。
		// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。

		// 和Executors.newCachedThreadPool()一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
				new SynchronousQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行
		// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0
		Thread.sleep(60000L);
		System.out.println(&quot;60秒后，再看线程池中的数量：&quot; + threadPoolExecutor.getPoolSize());
	}

	/**
	 * 延迟执行
	 * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest5() throws Exception {
		// 和Executors.newScheduledThreadPool()一样的
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		threadPoolExecutor.schedule(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;任务被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 3000, TimeUnit.MILLISECONDS);
		System.out.println(
				&quot;定时任务，提交成功，时间是：&quot; + System.currentTimeMillis() + &quot;, 当前线程池中线程数量：&quot; + threadPoolExecutor.getPoolSize());
		// 预计结果：任务在3秒后被执行一次
	}

	/**
	 * 周期性执行
	 * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest6() throws Exception {
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。
		// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别
		// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。
		// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）
		threadPoolExecutor.scheduleAtFixedRate(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-1 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);

		// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。
		// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）
		threadPoolExecutor.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-2 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	/**
	 * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest7() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		threadPoolExecutor.shutdown();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdown后，不接收新的任务，等待13任务执行结束
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	/**
	 * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest8() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		System.out.println(&quot;未结束的任务有：&quot; + shutdownNow.size());

		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	public static void main(String[] args) throws Exception {
		new Demo9().threadPoolExecutorTest1();
//		new Demo9().threadPoolExecutorTest2();
//		new Demo9().threadPoolExecutorTest3();
//		new Demo9().threadPoolExecutorTest4();
//		new Demo9().threadPoolExecutorTest5();
//		new Demo9().threadPoolExecutorTest6();
//		new Demo9().threadPoolExecutorTest7();
//		new Demo9().threadPoolExecutorTest8();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程封闭之ThreadLocal和栈封闭]]></title>
        <id>https://www.sunjianbo.com/thread-closure/</id>
        <link href="https://www.sunjianbo.com/thread-closure/">
        </link>
        <updated>2020-08-14T08:42:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程封闭的概念">线程封闭的概念</h2>
<p>多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，所以线程封闭概念就提出来了。</p>
<p>数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p>
<p>线程封闭具体的体现有： <strong>Thread Local</strong>、<strong>局部变量</strong></p>
<h2 id="threadlocal">ThreadLocal</h2>
<p>它是一个线程级别变量，每个线程都有一个 Thread Local,就是每个线程都拥有了自己独立的一个变量,竞争条件被彻底消除了，在并发模式下是绝对安全的变量。</p>
<p>用法： ThreadLocal<T>var= new ThreadLocal<T>()</p>
<p>会自动在每一个线程上创建一个T的副本，副本之间彼此独立，互不影响。</p>
<p>可以用 ThreadLocal存储一些参数，以便在线程中多个方法中使用，用来代替方法传参的做法。</p>
<blockquote>
<p>实在难以理解的，可以理解为，JVM维护了一个 Map&lt; Thread,T&gt;,每个线程要用这个T的时候，用当前的线程去Map里面取。仅作为一个概念理解</p>
</blockquote>
<p>代码示例:</p>
<pre><code class="language-java">/** 线程封闭示例 */
public class Demo5 {
	/** threadLocal变量，每个线程都有一个副本，互不干扰 */
	public static ThreadLocal&lt;String&gt; value = new ThreadLocal&lt;&gt;();

	/**
	 * threadlocal测试
	 * 
	 * @throws Exception
	 */
	public void threadLocalTest() throws Exception {

		// threadlocal线程封闭示例
		value.set(&quot;这是主线程设置的123&quot;); // 主线程设置值
		String v = value.get();
		System.out.println(&quot;线程1执行之前，主线程取到的值：&quot; + v);

		new Thread(new Runnable() {
			@Override
			public void run() {
				String v = value.get();
				System.out.println(&quot;线程1取到的值：&quot; + v);
				// 设置 threadLocal
				value.set(&quot;这是线程1设置的456&quot;);

				v = value.get();
				System.out.println(&quot;重新设置之后，线程1取到的值：&quot; + v);
				System.out.println(&quot;线程1执行结束&quot;);
			}
		}).start();

		Thread.sleep(5000L); // 等待所有线程执行结束

		v = value.get();
		System.out.println(&quot;线程1执行之后，主线程取到的值：&quot; + v);

	}

	public static void main(String[] args) throws Exception {
		new Demo5().threadLocalTest();
	}
}

</code></pre>
<p>运行结果:</p>
<blockquote>
<p>线程1执行之前，主线程取到的值：这是主线程设置的123<br>
线程1取到的值：null<br>
重新设置之后，线程1取到的值：这是线程1设置的456<br>
线程1执行结束<br>
线程1执行之后，主线程取到的值：这是主线程设置的123</p>
</blockquote>
<h2 id="栈封闭">栈封闭</h2>
<p><strong>局部变量</strong>的固有属性之一就是封闭在线程中.</p>
<p>它们位于执行线程的栈中,其他线程无法访问这个栈.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程通信]]></title>
        <id>https://www.sunjianbo.com/thread-communication/</id>
        <link href="https://www.sunjianbo.com/thread-communication/">
        </link>
        <updated>2020-08-07T04:13:43.000Z</updated>
        <content type="html"><![CDATA[<p>要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程执行的结果等等</p>
<p>涉及到线程之间相互通信，分为下面四类</p>
<h2 id="文件共享">文件共享</h2>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200612091611411.png" alt="" loading="lazy"></figure>
<h2 id="网络共享">网络共享</h2>
<p>略</p>
<h2 id="共享变量">共享变量</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200612091647383.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">  // 共享变量
  public static String content = &quot;空&quot;;
  
  public static void main(String[] args) {
    // 线程1 - 写入数据
    new Thread(() -&gt; {
      try {
        while (true) {
          content = &quot;当前时间&quot; + String.valueOf(System.currentTimeMillis());
          Thread.sleep(1000L);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();

    // 线程2 - 读取数据
    new Thread(() -&gt; {
      try {
        while (true) {
          Thread.sleep(1000L);
          System.out.println(content);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();
  }
</code></pre>
<h2 id="jdk提供的线程协调api">jdk提供的线程协调API</h2>
<p>JDK中对于需要多线程协作完成某一任务的场景，提供了对应API支持。</p>
<p>多线程协作的典型场景是：生产者-消费者模型(线程阻塞、线程唤醒)。</p>
<p>示例：线程1去买包子，没有包子，则不再执行。线程2生产出包子，通知线程-1继续执行。</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200612091856807.png" alt="" loading="lazy"></figure>
<h3 id="被弃用的suspend和resume">被弃用的suspend和resume</h3>
<p>作用:调用suspend挂起目标线程,通过resume可以恢复线程执行</p>
<h4 id="正常的suspendresume">正常的suspend/resume</h4>
<pre><code class="language-java">/** 包子店 */
public static Object baozidian = null;

/** 正常的suspend/resume */
public void suspendResumeTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="同步代码中使用导致死锁">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */
public void suspendResumeDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				Thread.currentThread().suspend();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		consumerThread.resume();
	}
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="resume比suspend先执行导致死锁">resume比suspend先执行导致死锁</h4>
<pre><code class="language-java">/** 导致程序永久挂起的suspend/resume */
public void suspendResumeDeadLockTest2() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) {
			System.out.println(&quot;1、没包子，进入等待&quot;);
			try { // 为这个线程加上一点延时
				Thread.sleep(5000L);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// 这里的挂起执行在resume后面
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
	consumerThread.join();
}
</code></pre>
<h3 id="waitnotify机制">wait/notify机制</h3>
<p>基于监视器实现,这些方法只能由<strong>同一对象锁的持有者线程</strong>调用，也就是写在同步块里面，否则会抛出IllegalMonitorStateException异常</p>
<p><strong>wait</strong>方法导致当前线程等待，其实就是将线程加入到对象的等待集合中，并且放弃当前持有的对象锁。</p>
<p><strong>notify/notifyall</strong>方法唤醒一个或所有正在等待这个对象锁的线程。</p>
<p><strong>注意：<strong>虽然会wait自动解锁，但是</strong>对顺序有要求</strong>，如果在 notify被调用之后，才开始wait方法的调用，线程会永远处于 WAITING状态。</p>
<h4 id="正常的waitnotify">正常的wait/notify</h4>
<pre><code class="language-java">/** 正常的wait/notify */
public void waitNotifyTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
			synchronized (this) {
				while (baozidian == null) { // 如果没包子，则进入等待
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h4 id="notify比wait先执行导致死锁">notify比wait先执行导致死锁</h4>
<pre><code class="language-java">/** 会导致程序永久等待的wait/notify */
public void waitNotifyDeadLockTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			try {
				Thread.sleep(5000L);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			synchronized (this) {
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h3 id="parkunpark机制">park/unpark机制</h3>
<p>线程调用park则等待&quot;许可(permit)&quot;.unpark方法为指定线程提供&quot;许可&quot;</p>
<p>不要求park和unpark方法的调用顺序</p>
<p>多次调用unpark后,再调用park,线程会直接运行,但<strong>许可不会叠加</strong>,</p>
<p>也就是说,连续多次调用park方法,第一次会拿到&quot;许可&quot;直接运行,后续调用依旧会进入等待.</p>
<h4 id="正常的parkunpark">正常的park/unpark</h4>
<pre><code class="language-java">/** 正常的park/unpark */
public void parkUnparkTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			LockSupport.park();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	LockSupport.unpark(consumerThread);
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h4 id="同步代码中使用导致死锁-2">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的park/unpark */
public void parkUnparkDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				LockSupport.park();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		LockSupport.unpark(consumerThread);
	}
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h3 id="伪唤醒">伪唤醒</h3>
<p><code>警告！之前代码中用if语句来判断，是否进入等待状态，是错误的！</code>(上文代码正常的都是使用的while)<br>
官方建议<code>应该在循环中检查等待条件</code>，原因是处于等待状态的线程可能会收到<code>错误警报和伪唤醒</code>，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>伪唤醒是指线程并非因为notify,notifyall,unpark等api调用而唤醒,是更底层原因导致的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CPU缓存和内存屏障]]></title>
        <id>https://www.sunjianbo.com/cpu-cache-and-memory-barrier/</id>
        <link href="https://www.sunjianbo.com/cpu-cache-and-memory-barrier/">
        </link>
        <updated>2020-08-06T03:40:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cpu缓存">CPU缓存</h2>
<p>为了提高程序运行的性能,现代CPU在很多方面对程序进行了优化.</p>
<p>例如:CPU高速缓存.尽可能地避免处理器访问主内存的时间开销,处理器大多会利用缓存(Cache)以提高性能.</p>
<h3 id="多级缓存">多级缓存</h3>
<h4 id="l1-cache一级缓存">L1 Cache(一级缓存)</h4>
<p>CPU第一层高速缓存,分为数据缓存和指令缓存.一般服务器CPU的L1缓存的容量在32---4096KB</p>
<h4 id="l2-cache">L2 Cache</h4>
<p>由于L1级高速缓存容量的限制,为了再次提高CPU的运算速度,在CPU外部放置一高速存储器,即二级缓存</p>
<h4 id="l3-cache">L3 Cache</h4>
<p>现在都是内置的,L3缓存的应用可以进一步降低内存延迟,同时提升大数据量计算时处理器的性能.具有较大L3缓存的处理器能提供更有效的文件系统缓存行为及较短消息和处理器队列长度.一般是多核共享一个L3缓存</p>
<p>CPU在读取数据时,先在L1中寻找,再从L2寻找,再从L3寻找,然后是内存,再后是外存储器(硬盘等)</p>
<h3 id="缓存同步协议">缓存同步协议</h3>
<p>多CPU读取同样的数据进行缓存,进行不同运算之后,最终写入主内存以哪个CPU为准?</p>
<p>在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。</p>
<p><strong>MESI协议</strong>，它规定每条缓存有个状态位，同时定义了下面四个状态:</p>
<ul>
<li>
<p>**修改态（ Modified）😗*此 cache行已被修改过（脏行），内容已不同于主存，为此 cache专有；</p>
</li>
<li>
<p>**专有态（ Exclusive）😗*此 cache行内容同于主存，但不出现于其它 cache中；</p>
</li>
<li>
<p>**共享态（ Shared）😗*此 cache行内容同于主存，但也出现于其它 cacher中；</p>
</li>
<li>
<p>**无效态（ Invalid）😗*此 cache？行内容无效（空行）。</p>
</li>
</ul>
<p>多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU.</p>
<p>也就是意味着，CPU处理要控制自己的读写操作，还要<strong>监听</strong>其他CPU发出的通知，从而保证<strong>最终一致</strong></p>
<h2 id="cpu指令重排">CPU指令重排</h2>
<h3 id="实例">实例</h3>
<pre><code class="language-java">//代码
x=100;
y=z;
</code></pre>
<p>正常执行的三步骤</p>
<blockquote>
<p>1、将100写入X<br>
2、读取z的值<br>
3、将z值写入y</p>
</blockquote>
<p>重排序后执行</p>
<blockquote>
<p>1、读取z的值<br>
2、将z值写入y<br>
3、将100写入X</p>
</blockquote>
<h3 id="指令重排的场景">指令重排的场景</h3>
<p>当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。</p>
<h3 id="as-if-serial">as-if- serial</h3>
<p>并非随便重排，需要遵守as-if- serial语义</p>
<p>as-if- serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p>编译器， runtime和处理器都必须遵守as-if- serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<h2 id="两个问题">两个问题</h2>
<h3 id="cpu高速缓存下的问题">CPU高速缓存下的问题</h3>
<p>缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。<strong>在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。</strong></p>
<h3 id="cpu执行指令重排序优化下的问题">CPU执行指令重排序优化下的问题</h3>
<p>虽然遵守了as- if-seriali语义，单仅在<strong>单CPU</strong>自己执行的情况下<strong>能保证结果正确</strong>。<br>
<strong>多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。</strong></p>
<h2 id="内存屏障">内存屏障</h2>
<p>为了解決上述两个问题,处理器提供了两个内存屏障指令（ Memory Barrier）</p>
<h3 id="写内存屏障-store-memory-barrier">写内存屏障（ Store Memory Barrier)</h3>
<p>在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>
<h3 id="读内存屏障-load-memory-barrier">读内存屏障（ Load Memory Barrier.)</h3>
<p>在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据。<br>
强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题</p>
<h2 id="结语">结语</h2>
<p>这个章节是后面<strong>JVM线程安全问题的铺垫</strong>。<br>
同时，也看到了现代CPU不断演进，在程序运行优化中做出的努力。不同CPU厂商所付出的人力物力成本，最终体现在不同CPU性能差距上。</p>
]]></content>
    </entry>
</feed>