<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-08-21T01:42:28.168Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[使用gitlab的webhook实现合并分支时在jira上打个标签的功能]]></title>
        <id>https://www.sunjianbo.com/webhook-jira/</id>
        <link href="https://www.sunjianbo.com/webhook-jira/">
        </link>
        <updated>2020-08-21T01:41:30.000Z</updated>
        <content type="html"><![CDATA[<p>公司通过gitlab托管代码,采用jira作为敏捷实践的管理工具,每次发布的时候拉出当前迭代的所有故事做发布计划.</p>
<p>然而实际上因为某些原因,基本上无法实现每次迭代的所有故事都能发布.只有在分支上测试完成合并到 master上的故事才会被发布.</p>
<p>那么就想着能不能在分支合并到master的时候在jira上打个标签,这样在jira上一筛选就知道哪些故事是可以发布的了</p>
<p>好在gitlab有webhook功能,能够在触发某些操作的时候调用自定义的接口传输相关操作的信息,而jira也提供了相应的api来方便读写,那么只需要发布一个服务提供接口给webhook调用,解析传过来的参数,符合条件的情况下去调用jira的api修改标签,这个方案也就实现了.</p>
<h2 id="本文相关版本信息">本文相关版本信息</h2>
<blockquote>
<p>GitLab Community Edition 11.1.4</p>
<p>JIRA v7.13.5</p>
<p>python 3.5.4</p>
<p>Flask 1.1.2</p>
<p>requests 2.24.0</p>
</blockquote>
<h2 id="提前约定">提前约定</h2>
<p>在git创建分支时分支名称需要包含jiraId</p>
<p>我们项目组是直接以jiraId+故事标题命名分支</p>
<h2 id="编写程序">编写程序</h2>
<p>图快速方便所以用python写的,结果后面部署费了不少事</p>
<h3 id="webhook调用接口传递参数解析">webhook调用接口传递参数解析</h3>
<p>文档: https://docs.gitlab.com/ee/user/project/integrations/webhooks.html</p>
<p>参数是json形式的</p>
<p>主要取出其中3个参数</p>
<ul>
<li>
<p>object_attributes.state</p>
<p>gitlab设置的trigger是合并事件,实际上会在申请(opened),关闭(closed)和完成合并(merged)3个情况触发,所以要判断是否是完成合并的调用</p>
</li>
<li>
<p>object_attributes.target_branch</p>
<p>target_branch 是为了确认是合并到master的请求,合并到其他分支的请求不处理</p>
</li>
<li>
<p>object_attributes. source_branch</p>
<p>source_branch 是为了取出jiraId以进行后续操作</p>
</li>
</ul>
<h3 id="jira接口调用">jira接口调用</h3>
<p>文档: https://developer.atlassian.com/server/jira/platform/jira-rest-api-examples/#editing-an-issue-examples</p>
<p>从source_branch利用正则截取出jiraId,拼装并调用接口地址</p>
<p>附三个修改标签的传参,第一个是追加,后两种是覆盖设置</p>
<pre><code>#增加
{
    &quot;update&quot; : {
        &quot;labels&quot; : [{&quot;add&quot; : &quot;标签内容&quot;}]
    }
}
#设置
{
    &quot;fields&quot; : {
        &quot;labels&quot;: [&quot;标签内容&quot;]
        
        
    }
}
{
    &quot;update&quot; : {
        &quot;labels&quot; : [{&quot;set&quot; : [&quot;标签内容&quot;]}]
    }
}
</code></pre>
<h4 id="ps">PS:</h4>
<p>建议先用postman之类的工具先调试一下jira的接口,如果报错</p>
<blockquote>
<p>Field 'labels' cannot be set. It is not on the appropriate screen, or unknown.</p>
</blockquote>
<p>那就需要联系jira管理员,在项目的screens(项目管理-&gt;界面)中开启相关字段的api读写权限</p>
<h3 id="完整源码如下">完整源码如下:</h3>
<pre><code class="language-python"># -*- coding: utf-8 -*-

from flask import Flask,request
import requests
import re

baseUrl = 'http://jira.sunjianbo.com:8080/rest/api/2/issue/'
app = Flask(__name__)

@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def test():
    # addTag2Jira(&quot;DB19236-2398 324扥矿赛肯&quot;)
    return &quot;hello world&quot;

@app.route(&quot;/merged&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def merged():
    # print(request.headers)
    # print(request.json)
    # print('---')
    body = request.json
    object_attributes = body['object_attributes']
    state = object_attributes['state']  # opened,closed,merged
    source_branch = object_attributes['source_branch']
    target_branch = object_attributes['target_branch']
    if state == 'merged' and target_branch == 'master':
        # 已合并到master
        print('是已合并到master的请求,开始修改jira标签')
        addTag2Jira(source_branch)
    else:
        print('不是合并到master的成功请求,而是合并到['+target_branch+']的['+state+&quot;]请求&quot;)
    return &quot;&quot;

def addTag2Jira(source_branch):
    # 取得分支jira id
    matchObj = re.search(r&quot;DB\d+-\d+&quot;, source_branch)
    if matchObj:
        print(&quot;匹配出的jiraId: &quot;, matchObj.group())
        jiraId = matchObj.group()
        # 去相应jira故事中打一个uat标签
        url = baseUrl + jiraId
        messagebody = '''
            {
                &quot;update&quot; : {
                    &quot;labels&quot; : [{&quot;add&quot; : &quot;UAT&quot;}]
                }
            }
            '''
        result = fun_put(url, messagebody)
        print(result)
        if result.status_code == 204:
            print('修改成功: ' + url)
        else:
            print('修改失败: ' + source_branch)
    else:
        print(&quot;分支名称上找不到jiraId: &quot; + source_branch)

def fun_put(url, messagebody):
    headers = {'content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
    r = requests.put(url, data=messagebody, headers=headers, auth=('username', 'passwd'))
    print(r.status_code)
    return r

if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;0.0.0.0&quot;, port=8080)
</code></pre>
<h2 id="部署">部署</h2>
<p>部署这里有个插曲</p>
<p>公司服务器是离线的,所以我先离线安装了python3,然后打算安装virtualenv时报了一个ssl的错误,明明是离线安装,为毛会涉及到ssl,咱也不知道,咱也不敢问,推测是python3安装的有点问题,依赖的openssl之类的在测试机上不太全吧</p>
<p>折腾了半天没搞定,考虑到是测试服务器我就瞎搞了一把</p>
<p>用了</p>
<pre><code>pip3 install -r requirements.txt --proxy=代理服务器IP:端口号
</code></pre>
<p>代理走了我本地电脑在线安装了Flask和 requests,瞬间就解决了(给机智的我点个赞(◔◡◔))</p>
<h2 id="设置gitlab上的webhook">设置gitlab上的webhook</h2>
<p>settings-&gt;integrations-&gt;填写url-&gt;Trigger勾选<code>Merge request events</code>-&gt;嫌麻烦我禁用了ssl,没有实际测试一下行不行-&gt;保存</p>
<p><img src="https://static.sunjianbo.com/image-20200820160206463.png" alt="set-integrations" loading="lazy">)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存模型(理论很枯燥)]]></title>
        <id>https://www.sunjianbo.com/jmm/</id>
        <link href="https://www.sunjianbo.com/jmm/">
        </link>
        <updated>2020-08-20T07:52:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="多线程中的问题">多线程中的问题</h2>
<ol>
<li>所见非所得</li>
<li>无法肉眼去检测程序的准确性</li>
<li>不同的运行平台有不同的表现</li>
<li>错误很难重现</li>
</ol>
<h2 id="问题示例">问题示例</h2>
<p>将运行模式设置为-server， 变成死循环   。 没加默认就是client模式，就是正常（可见性问题）</p>
<pre><code class="language-java">import java.util.concurrent.TimeUnit;

// 1、 jre/bin/server  放置hsdis动态链接库
//  测试代码 将运行模式设置为-server， 变成死循环   。 没加默认就是client模式，就是正常（可见性问题）
// 2、 通过设置JVM的参数，打印出jit编译的内容 （这里说的编译非class文件），通过可视化工具jitwatch进行查看
// -server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log
//  关闭jit优化-Djava.compiler=NONE
public class VisibilityDemo {
    private volatile boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        VisibilityDemo demo1 = new VisibilityDemo();
        Thread thread1 = new Thread(new Runnable() {
            public void run() {
                int i = 0;
                // class -&gt;  运行时jit编译  -&gt; 汇编指令 -&gt; 重排序
                while (demo1.flag) { // 指令重排序
                    i++;
                }
                System.out.println(i);
            }
        });
        thread1.start();

        TimeUnit.SECONDS.sleep(2);
        // 设置is为false，使上面的线程结束while循环
        demo1.flag = false;
        System.out.println(&quot;被置为false了.&quot;);
    }
}
</code></pre>
<h3 id="死循环可能的两个原因">死循环可能的两个原因:</h3>
<h4 id="cpu缓存">CPU缓存</h4>
<p>​	CPU缓存在这里会导致线程读取的flag延迟一些变为false,但不会发生死循环</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200813093851143.png" alt="工作内存缓存" loading="lazy"></figure>
<h4 id="指令重排序">指令重排序</h4>
<p>Java编程语言的语义允许**编译器和微处理器(JIT)**执行优化,这些优化可以与不正确的同步代码交互,从而产生看似矛盾的行为。</p>
<ol>
<li>执行顺序的重排序</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200813094122201.png" alt="image-20200813094122201" loading="lazy"></figure>
<ol start="2">
<li>等效替换的重排序</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200813094209877.png" alt="image-20200813094209877" loading="lazy"></figure>
<p>虽然有as-if- serial的原则,但是因为多CPU的情况就变得复杂了,每个cpu只能保证自己的重排序是没有问题的</p>
<h3 id="真正原因">真正原因</h3>
<p>汇编层面的重排序会将<code>while(demo1.flag)</code>变为</p>
<pre><code> if(demo1.flag){
     while(true){
         i++
     }
 }
</code></pre>
<p>它认为demo1.flag基本不变就是true</p>
<h3 id="附-jitwatch使用">附: JITWatch使用</h3>
<p>可直接参考这个操作博客<br>
http://www.cnblogs.com/stevenczp/p/7975776.html<br>
https://www.cnblogs.com/stevenczp/p/7978554.html</p>
<ol>
<li>
<p>输出jit日志</p>
<ol>
<li>（windows）在jre/bin/server  放置hsdis动态链接库</li>
<li>eclise、idea等工具，加上JVM参数<br>
-server -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log</li>
</ol>
</li>
<li>
<p>工具安装<br>
下载  https://github.com/AdoptOpenJDK/jitwatch</p>
</li>
<li>
<p>解压 通过maven运行</p>
</li>
</ol>
<pre><code>mvn clean compile exec:java
</code></pre>
<ol start="4">
<li>
<p>配置jitwatch<br>
页面选择 config， 配置要调试的项目src源码路径，和class编译路径<br>
打开jit.log<br>
点击start</p>
</li>
<li>
<p>在分析的结果中，选中指定的类，再选择右侧的具体方法，则弹出jit编译结果</p>
</li>
</ol>
<hr>
<p>为了解决多线程的问题,提出了一种规范,就是内存模型</p>
<h2 id="内存模型memory-model的定义">内存模型(Memory Model)的定义</h2>
<p>内存模型描述程序的可能行为。</p>
<p><strong>Java编程语言内存模型</strong>通过检查执行跟踪中的每个读操作,并根据某些规则检查该读操作观察到的写操作是否有效来工作。</p>
<p>要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现,包括操作的重新排序和删除不必要的同步。</p>
<blockquote>
<p>内存模型决定了在程序的每个点上可以读取什么值</p>
<p>比如说线程1的操作让线程2能及时看到改变,也就是说在这个点上线程2可以且必须读到它应该读取的正确的值</p>
</blockquote>
<h3 id="shared-variables共享变量">Shared variables共享变量</h3>
<p>描述可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段、静态字段和数组元素都存储在堆内存中。</p>
<p>如果至少有一个访问是写的,那么对同一个变量的两次访问(读或写)是冲突的。</p>
<p>这句话定义在:https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jis-17.4.1</p>
<h3 id="线程间操作的定义">线程间操作的定义</h3>
<ul>
<li>write要写的变量以及要写的值。</li>
<li>read要读的变量以及可见的写入值(由此,我们可以确定可见的值)</li>
<li>lock要锁定的管程(监视器 monitor)</li>
<li>unlock要解锁的管程。</li>
<li>外部操作(socket等等..)</li>
<li>启动和终止</li>
</ul>
<p>程序顺序: 如果一个程序没有数据竞争,那么程序的所有执行看起来都是顺序一致的</p>
<p>本规范只涉及线程间的操作</p>
<h3 id="对于同步的规则定义">对于同步的规则定义</h3>
<p><em>同步我理解就是对一些操作约定了固定的先后顺序,且后面能看到前面的操作</em></p>
<ul>
<li>对于监视器m的解锁与所有后续操作对于m的加锁同步</li>
<li>对 volatile变量v的写入,与所有其他线程后续对v的读同步</li>
<li>启动线程的操作与线程中的第一个操作同步</li>
<li>对于每个属性写入默认值(0, false,null)与每个线程对其进行的操作同步</li>
<li>线程T1的最后操作与线程T2发现线程T1已经结束同步(isAlive, join可以判断线程是否终结)</li>
<li>如果线程T1中断了T2,那么线程T1的中断操作与其他所有线程发现T2被中断了同步(通过抛出InterruptedException异常,或者调用Thread.interrupted或Thread.isInterrupted)</li>
</ul>
<h3 id="happens-before先行发生原则">Happens- before先行发生原则</h3>
<p>happens-before关系主要用于强调两个有冲突的动作之间的顺序,以及定义数据争用的发生时机。</p>
<p>具体的虚拟机实现,有必要确保以下原则的成立</p>
<ul>
<li>某个线程中的每个动作都 happens-before该线程中该动作后面的动作</li>
<li>某个管程上的 unlock动作 happens-before同一个管程上后续的lock动作</li>
<li>对某个 volatile字段的写操作 happens-before每个后续对该 volatile字段的读操作</li>
<li>在某个线程对象上调用 start()方法 happens-before该启动了的线程中的任意动作</li>
<li>某个线程中的所有动作 happens-before任意其它线程成功从该线程对象上的join()中返回</li>
<li>如果某个动作a happens-before动作b,且b happens-before动作c,则有 a happens-before c</li>
</ul>
<p>当程序包含两个没有被 happens-before关系排序的冲突访问时,就称存在<strong>数据争用</strong></p>
<p>遵守了这个原则,也就意味着有些代码不能进行重排序,有些数据不能缓存!</p>
<h2 id="一些实践">一些实践</h2>
<h3 id="volatile关键字">volatile关键字</h3>
<p>可见性问题:让一个线程对共享变量的修改,能够及时的被其他线程看到。</p>
<blockquote>
<p>根据JMM中规定的 happen before和同步原则:</p>
<p>对某个 volatile字段的写操作 happens-before每个后续对该 volatile字段的读操作。</p>
<p>对 volatile变量v的写入,与所有其他线程后续对v的读同步</p>
</blockquote>
<p>要满足这些条件,所以 volatile关键字就有这些功能:</p>
<ol>
<li>
<p>禁止缓存:</p>
<p>volatile变量的访问控制符会加个 ACC VOLATILE</p>
<p>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#tjvms-4.5</p>
</li>
<li>
<p>对 volatile变量相关的指令不做重排序</p>
</li>
</ol>
<h3 id="fina在jmm中的处理">fina在JMM中的处理</h3>
<ul>
<li>final在该对象的构造函数中设置对象的字段,当线程看到该对象时,将始终看到该对象的final字段的正确构造版本。<br>
伪代码示例: <code>f= new finalDemo();</code>读取到的f.x一定最新,x为final字段。而y可能是0</li>
</ul>
<pre><code class="language-java">// 官方示例，可能会读取到y的值为0
class FinalFieldExample {
    final int x;
    int y;
    static FinalFieldExample f;

    public FinalFieldExample() {
        x = 3;
        y = 4;
    }

    static void writer() {
        f = new FinalFieldExample();
    }

    static void reader() {
        if (f != null) {
            int i = f.x;  // guaranteed to see 3 肯定是3
            int j = f.y;  // could see 0 可能看到0
        }
    }
}
</code></pre>
<ul>
<li>
<p>如果在构造函数中设置字段后发生读取,则会看到该final字段分配的值,否则它将看到默认值;<br>
伪代码示例: <code>public finalDemo(){x=1;y=x;};</code>y会等于1;</p>
</li>
<li>
<p>读取该共享对象的final成员变量之前,先要读取共享对象。<br>
伪代码示例:<code>r = new ReferenceObj();k=r.f;</code>这两个操作不能重排序</p>
</li>
<li>
<p>通常<code>static final</code>是不可以修改的字段。然而<code>System.in</code>,<code>System.out</code>和 <code>System.err</code>是 <code>static final</code>字段,遗留原因,必须允许通过set方法改变,我们将这些字段称为写保护,以区别于普通final字段;</p>
</li>
</ul>
<h3 id="word-tearing字节处理">Word Tearing字节处理</h3>
<p>一个字段或元素的更新不得与任何其他字段或元素的读取或更新交互。</p>
<p>特别是,分别更新字节数组的相邻元素的两个线程不得干涉或交互,也不需要同步以确保顺序一致性。</p>
<p>有些处理器(尤其是早期的Alphas处理器)没有提供写单个字节的功能</p>
<p>在这样的处理器上更新byte数组,若只是简单地读取整个内容,更新对应的字节,然后将整个内容再写回内存,将是不合法的。</p>
<p>这个问题有时候被称为**“字分裂 word tearing)”**,在单独更新单个字节有难度的处理器上,就需要寻求其它方式了。</p>
<p>基本不需要考虑这个,了解就好。</p>
<pre><code class="language-java">// https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4
// 官方提供的示例，检查有没有WordTearing情况
public class WordTearing extends Thread {
    static final int LENGTH = 8;
    static final int ITERS = 1000000;
    static byte[] counts = new byte[LENGTH];
    static Thread[] threads = new Thread[LENGTH];

    final int id;

    WordTearing(int i) {
        id = i;
    }

    public void run() {
        byte v = 0;
        for (int i = 0; i &lt; ITERS; i++) {
            byte v2 = counts[id];
            if (v != v2) {
                System.err.println(&quot;Word-Tearing found: &quot; +
                        &quot;counts[&quot; + id + &quot;] = &quot; + v2 +
                        &quot;, should be &quot; + v);
                return;
            }
            v++;
            counts[id] = v;
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; LENGTH; ++i)
            (threads[i] = new WordTearing(i)).start();
    }
}
</code></pre>
<h3 id="double和long的特殊处理">double和long的特殊处理</h3>
<p>虚拟机规范中,写64位的 double和long分成了两次32位值的操作</p>
<p>由于不是原子操作,可能导致读取到某次写操作中64位的前32位,以及另外一次写操作的后32位</p>
<figure data-type="image" tabindex="4"><img src="https://static.sunjianbo.com/image-20200814163308291.png" alt="image-20200814163308291" loading="lazy"></figure>
<p>读写 volatile的long和 double总是原子的。读写引用也总是原子的</p>
<blockquote>
<p>商业JⅥM不会存在这个问题,虽然规范没要求实现原子性,但是考虑到实际应用,大部分都实现了原子性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池应用及实现原理剖析]]></title>
        <id>https://www.sunjianbo.com/thread-pool/</id>
        <link href="https://www.sunjianbo.com/thread-pool/">
        </link>
        <updated>2020-08-17T07:30:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="为什么要用线程池">为什么要用线程池</h2>
<p>线程是不是越多越好?</p>
<ol>
<li>线程在java中是一个对象,更是操作系统的资源,线程创建、销毁需要时间。如果创建时间+销毁时间&gt;执行任务时间就很不合算。</li>
<li>java对象占用堆内存,操作系统线程占用系统内存,根据jνm规范,一个线程默认最大栈大小1M,这个栈空间是需要从系统内存中分配的。线程过多,会消耗很多的內存。</li>
<li>操作系统需要频繁切换线程上下文(大家都想被运行),影响性能。</li>
</ol>
<p>线程池的推出,就是为了方便的控制线程数量。</p>
<h2 id="线程池原理-概念">线程池原理 - 概念</h2>
<h4 id="线程池管理器">线程池管理器</h4>
<p>用于创建并管理线程池,包括创建线程池,销毁线程池,添加新任务;</p>
<h4 id="工作线程">工作线程</h4>
<p>线程池中线程,在没有任务时处于等待状态,可以循环的执行任务;</p>
<h4 id="任务接口">任务接口</h4>
<p>每个任务必须实现的接口,以供工作线程调度任务的执行,它主要规定了任务的入口,任务执行完后的收尾工作,任务的执行状态等;</p>
<h4 id="任务队列">任务队列</h4>
<p>用于存放没有处理的任务。提供一种缓冲机制。</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200805095038062.png" alt="" loading="lazy"></figure>
<h2 id="线程池api-接口定义和实现类">线程池API - 接口定义和实现类</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口</td>
<td>Executor</td>
<td>最上层的接口,定义了<font color=red>执行任务的方法 execute</font></td>
</tr>
<tr>
<td>接口</td>
<td>ExecutorService</td>
<td>继承了 Executor接口,拓展了 Callable、 Future、关闭方法</td>
</tr>
<tr>
<td>接口</td>
<td>ScheduledExecutorService</td>
<td>继承了 ExecutorService,增加了定时任务相关的方法</td>
</tr>
<tr>
<td>实现类</td>
<td>ThreadPoolExecutor</td>
<td><font color=red>基础、标准的线程池实现</font></td>
</tr>
<tr>
<td>实现类</td>
<td>ScheduledThreadPoolExecutor</td>
<td>继承了 ThreadPoolExecutor,实现了ScheduledExecutorService中相关<font color=red>定时任务</font>的方法</td>
</tr>
</tbody>
</table>
<h2 id="线程池api-方法定义">线程池API - 方法定义</h2>
<h3 id="executorservice">ExecutorService</h3>
<pre><code class="language-java">//监测ExecutorService是否已经关闭， 直到所有任务完成执行，或超时发生，或当前线程被中断
awaitTermination(long timeout, TimeUnit unit)
//执行给定的任务集合，执行完毕后，返回结果
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务集合，执行完毕或者超时后，返回结果，其他任务终止
invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//执行给定的任务，任意一个执行成功则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
//执行给定的任务，任意一个执行成功或者超时后，则返回结果，其他任务终止
invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)
//如果此线程池已关闭，则返回true。
isShutdown()
//如果关闭后所有任务都已完成，则返回true。
isTerminated()
//优雅关闭线程池，之前提交的任务将被执行，但是不会接受新的任务。
shutdown()
//尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行任务的列表。
shutdownNow()
//提交个用于执行的Callable返回任务，并返回一个Future,用于获取Callable执行结果
submit(Callable&lt;T&gt; task)
//提交可运行任务以执行，并发回一个Future对象，执行结果为null
submit(Runnable task)
//提交可运行任务以执行，并返回Future, 执行结果为传入的result
submit(Runnable task, T result)
</code></pre>
<h3 id="scheduledexecutorservice">ScheduledExecutorService</h3>
<ul>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个一次性任务,过了延迟时间就会被执行</p>
</li>
<li>
<p><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务过了给定的初始延迟时间,会第一次被执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会等到该次任务执行结束后,立刻执行,这也是它和<code>scheduleWithFixedDelay</code>的重要区别。<br>
此处结合代码示例进行理解即可!</p>
</li>
<li>
<p><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></p>
<p>创建并执行一个周期性任务,过了初始延迟时间,第一次被执行,后续以给定的周期时间执行</p>
<p>执行过程中发生了异常,那么任务就停止</p>
<p>一次任务执行时长超过了周期时间,下一次任务会在该次任务执行结束的时间基础上,计算执行延时。</p>
<p>对于超过周期的长时间处理任务的不同处理方式,这是它和<code>scheduleAtFixedRate</code>的重要区别。</p>
</li>
</ul>
<h2 id="线程池api-executors工具类">线程池API - Executors工具类</h2>
<p>你可以自己实例化线程池,也可以用 Executors创建线程池的工厂类,常用方法如下:</p>
<h3 id="newfixedthreadpoolint-nthreads">newFixedThreadPool(int nThreads)</h3>
<p>创建一个固定大小、任务队列容量无界的线程池。核心线程数=最大线程数。</p>
<h3 id="newcachedthreadpool">newCachedThreadPool()</h3>
<p>创建的是一个大小无界的缓冲线程池。它的任务队列是一个同步队列。</p>
<p>任务加入到池中,如果池中有空闲线程,则用空闲线程执行,如无则创建新线程执行。</p>
<p>池中的线程空闲超过60秒,将被销毁释放。线程数随任务的多少变化。</p>
<p>适用于执行耗时较小的异步任务。池的核心线程数=0,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h3 id="newsinglethreadexecutor">newSingleThreadExecutor()</h3>
<p>只有一个线程来执行无界任务队列的单一线程池。</p>
<p>该线程池确保任务按加入的顺序一个个依次执行。当唯一的线程因任务异常中止时,将创建一个新的线程来继续执行后续的任务。</p>
<p>与 <code>newFixedThreadPool(1)</code>的区别在于,单一线程池的池大小在<code>newSingleThreadExecutor</code>方法中硬编码,不能再改变的。</p>
<h3 id="newscheduledthreadpoolint-corepoolsize">newScheduledThreadPool(int corePoolSize)</h3>
<p>能定时执行任务的线程池。该池的核心线程数由参数指定,最大线程数= <code>Integer.MAX_VALUE</code></p>
<h2 id="线程池原理-任务execute过程">线程池原理-任务execute过程</h2>
<ol>
<li>
<p>是否达到核心线程数量?</p>
<p>没达到,创建一个工作线程来执行任务。</p>
</li>
<li>
<p>工作队列是否已满?</p>
<p>没满,则将新提交的任务存储在工作队列里。</p>
</li>
<li>
<p>是否达到线程池最大数量?</p>
<p>没达到,则创建一个新的工作线程来执行任务。</p>
</li>
<li>
<p>最后,执行拒绝策略来处理这个任务。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200806112820086.png" alt="" loading="lazy"></figure>
<h2 id="实践-合适的线程数量">实践 - 合适的线程数量</h2>
<p>如何确定合适数量的线程?</p>
<ul>
<li>
<p>计算型任务:</p>
<p>CPU数量的1-2倍</p>
</li>
<li>
<p>IO型任务:</p>
<p>相对比计算型任务,需多一些线程,要根据具体的<u>IO阻塞时长</u>进行考量决定。<br>
如 tomcat中默认的最大线程数为: 200。</p>
</li>
</ul>
<p>也可考虑根据需要在一个<u>最小数量和最大数量间</u>自动增减线程数。(<code>newCachedThreadPool</code>)</p>
<h2 id="代码示例">代码示例:</h2>
<pre><code class="language-java">import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/** 线程池的使用 */
public class Demo9 {

	/**
	 * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况
	 * 
	 * @param threadPoolExecutor 传入不同的线程池，看不同的结果
	 * @throws Exception
	 */
	public void testCommon(ThreadPoolExecutor threadPoolExecutor) throws Exception {
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 查看线程数量，查看队列等待数量
		Thread.sleep(500L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
		// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）
		Thread.sleep(15000L);
		System.out.println(&quot;当前线程池线程数量为：&quot; + threadPoolExecutor.getPoolSize());
		System.out.println(&quot;当前线程池等待的数量为：&quot; + threadPoolExecutor.getQueue().size());
	}

	/**
	 * 标准线程池
	 * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest1() throws Exception {
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());

		testCommon(threadPoolExecutor);
		// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 有拒绝策略的
	 * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest2() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 5个任务直接分配线程开始执行
		// 2、 3个任务进入等待队列
		// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)
		// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。
		// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程
	}

	/**
	 * 自定义Executors.newFixedThreadPool(int nThreads)
	 * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest3() throws Exception {
		// 和Executors.newFixedThreadPool(int nThreads)一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行
	}

	/**
	 * 自定义Executors.newCachedThreadPool()
	 * 4、 线程池信息：
	 * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest4() throws Exception {

		// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。
		// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，
		// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，
		// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。
		// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。

		// 和Executors.newCachedThreadPool()一样的
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
				new SynchronousQueue&lt;Runnable&gt;());
		testCommon(threadPoolExecutor);
		// 预计结果：
		// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行
		// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0
		Thread.sleep(60000L);
		System.out.println(&quot;60秒后，再看线程池中的数量：&quot; + threadPoolExecutor.getPoolSize());
	}

	/**
	 * 延迟执行
	 * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest5() throws Exception {
		// 和Executors.newScheduledThreadPool()一样的
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		threadPoolExecutor.schedule(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;任务被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 3000, TimeUnit.MILLISECONDS);
		System.out.println(
				&quot;定时任务，提交成功，时间是：&quot; + System.currentTimeMillis() + &quot;, 当前线程池中线程数量：&quot; + threadPoolExecutor.getPoolSize());
		// 预计结果：任务在3秒后被执行一次
	}

	/**
	 * 周期性执行
	 * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/&gt;
	 * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest6() throws Exception {
		ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor(5);
		// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。
		// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别
		// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。
		// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）
		threadPoolExecutor.scheduleAtFixedRate(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-1 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);

		// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。
		// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）
		threadPoolExecutor.scheduleWithFixedDelay(new Runnable() {
			@Override
			public void run() {
				try {
					Thread.sleep(3000L);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;任务-2 被执行，现在时间：&quot; + System.currentTimeMillis());
			}
		}, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	/**
	 * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest7() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		threadPoolExecutor.shutdown();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdown后，不接收新的任务，等待13任务执行结束
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	/**
	 * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的
	 * 
	 * @throws Exception
	 */
	private void threadPoolExecutorTest8() throws Exception {
		// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。
		// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy
		ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5, TimeUnit.SECONDS,
				new LinkedBlockingQueue&lt;Runnable&gt;(3), new RejectedExecutionHandler() {
					@Override
					public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
						System.err.println(&quot;有任务被拒绝执行了&quot;);
					}
				});
		// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况
		for (int i = 0; i &lt; 15; i++) {
			int n = i;
			threadPoolExecutor.submit(new Runnable() {
				@Override
				public void run() {
					try {
						System.out.println(&quot;开始执行：&quot; + n);
						Thread.sleep(3000L);
						System.err.println(&quot;执行结束:&quot; + n);
					} catch (InterruptedException e) {
						System.out.println(&quot;异常：&quot; + e.getMessage());
					}
				}
			});
			System.out.println(&quot;任务提交成功 :&quot; + i);
		}
		// 1秒后终止线程池
		Thread.sleep(1000L);
		List&lt;Runnable&gt; shutdownNow = threadPoolExecutor.shutdownNow();
		// 再次提交提示失败
		threadPoolExecutor.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;追加一个任务&quot;);
			}
		});
		System.out.println(&quot;未结束的任务有：&quot; + shutdownNow.size());

		// 结果分析
		// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行
		// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止
		// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行
	}

	public static void main(String[] args) throws Exception {
		new Demo9().threadPoolExecutorTest1();
//		new Demo9().threadPoolExecutorTest2();
//		new Demo9().threadPoolExecutorTest3();
//		new Demo9().threadPoolExecutorTest4();
//		new Demo9().threadPoolExecutorTest5();
//		new Demo9().threadPoolExecutorTest6();
//		new Demo9().threadPoolExecutorTest7();
//		new Demo9().threadPoolExecutorTest8();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程封闭之ThreadLocal和栈封闭]]></title>
        <id>https://www.sunjianbo.com/thread-closure/</id>
        <link href="https://www.sunjianbo.com/thread-closure/">
        </link>
        <updated>2020-08-14T08:42:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程封闭的概念">线程封闭的概念</h2>
<p>多线程访问共享可变数据时，涉及到线程间数据同步的问题。并不是所有时候，都要用到共享数据，所以线程封闭概念就提出来了。</p>
<p>数据都被封闭在各自的线程之中，就不需要同步，这种通过将数据封闭在线程中而避免使用同步的技术称为<strong>线程封闭</strong>。</p>
<p>线程封闭具体的体现有： <strong>Thread Local</strong>、<strong>局部变量</strong></p>
<h2 id="threadlocal">ThreadLocal</h2>
<p>它是一个线程级别变量，每个线程都有一个 Thread Local,就是每个线程都拥有了自己独立的一个变量,竞争条件被彻底消除了，在并发模式下是绝对安全的变量。</p>
<p>用法： ThreadLocal<T>var= new ThreadLocal<T>()</p>
<p>会自动在每一个线程上创建一个T的副本，副本之间彼此独立，互不影响。</p>
<p>可以用 ThreadLocal存储一些参数，以便在线程中多个方法中使用，用来代替方法传参的做法。</p>
<blockquote>
<p>实在难以理解的，可以理解为，JVM维护了一个 Map&lt; Thread,T&gt;,每个线程要用这个T的时候，用当前的线程去Map里面取。仅作为一个概念理解</p>
</blockquote>
<p>代码示例:</p>
<pre><code class="language-java">/** 线程封闭示例 */
public class Demo5 {
	/** threadLocal变量，每个线程都有一个副本，互不干扰 */
	public static ThreadLocal&lt;String&gt; value = new ThreadLocal&lt;&gt;();

	/**
	 * threadlocal测试
	 * 
	 * @throws Exception
	 */
	public void threadLocalTest() throws Exception {

		// threadlocal线程封闭示例
		value.set(&quot;这是主线程设置的123&quot;); // 主线程设置值
		String v = value.get();
		System.out.println(&quot;线程1执行之前，主线程取到的值：&quot; + v);

		new Thread(new Runnable() {
			@Override
			public void run() {
				String v = value.get();
				System.out.println(&quot;线程1取到的值：&quot; + v);
				// 设置 threadLocal
				value.set(&quot;这是线程1设置的456&quot;);

				v = value.get();
				System.out.println(&quot;重新设置之后，线程1取到的值：&quot; + v);
				System.out.println(&quot;线程1执行结束&quot;);
			}
		}).start();

		Thread.sleep(5000L); // 等待所有线程执行结束

		v = value.get();
		System.out.println(&quot;线程1执行之后，主线程取到的值：&quot; + v);

	}

	public static void main(String[] args) throws Exception {
		new Demo5().threadLocalTest();
	}
}

</code></pre>
<p>运行结果:</p>
<blockquote>
<p>线程1执行之前，主线程取到的值：这是主线程设置的123<br>
线程1取到的值：null<br>
重新设置之后，线程1取到的值：这是线程1设置的456<br>
线程1执行结束<br>
线程1执行之后，主线程取到的值：这是主线程设置的123</p>
</blockquote>
<h2 id="栈封闭">栈封闭</h2>
<p><strong>局部变量</strong>的固有属性之一就是封闭在线程中.</p>
<p>它们位于执行线程的栈中,其他线程无法访问这个栈.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程通信]]></title>
        <id>https://www.sunjianbo.com/thread-communication/</id>
        <link href="https://www.sunjianbo.com/thread-communication/">
        </link>
        <updated>2020-08-07T04:13:43.000Z</updated>
        <content type="html"><![CDATA[<p>要想实现多个线程之间的协同，如：线程执行先后顺序、获取某个线程执行的结果等等</p>
<p>涉及到线程之间相互通信，分为下面四类</p>
<h2 id="文件共享">文件共享</h2>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200612091611411.png" alt="" loading="lazy"></figure>
<h2 id="网络共享">网络共享</h2>
<p>略</p>
<h2 id="共享变量">共享变量</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200612091647383.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">  // 共享变量
  public static String content = &quot;空&quot;;
  
  public static void main(String[] args) {
    // 线程1 - 写入数据
    new Thread(() -&gt; {
      try {
        while (true) {
          content = &quot;当前时间&quot; + String.valueOf(System.currentTimeMillis());
          Thread.sleep(1000L);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();

    // 线程2 - 读取数据
    new Thread(() -&gt; {
      try {
        while (true) {
          Thread.sleep(1000L);
          System.out.println(content);
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }).start();
  }
</code></pre>
<h2 id="jdk提供的线程协调api">jdk提供的线程协调API</h2>
<p>JDK中对于需要多线程协作完成某一任务的场景，提供了对应API支持。</p>
<p>多线程协作的典型场景是：生产者-消费者模型(线程阻塞、线程唤醒)。</p>
<p>示例：线程1去买包子，没有包子，则不再执行。线程2生产出包子，通知线程-1继续执行。</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/image-20200612091856807.png" alt="" loading="lazy"></figure>
<h3 id="被弃用的suspend和resume">被弃用的suspend和resume</h3>
<p>作用:调用suspend挂起目标线程,通过resume可以恢复线程执行</p>
<h4 id="正常的suspendresume">正常的suspend/resume</h4>
<pre><code class="language-java">/** 包子店 */
public static Object baozidian = null;

/** 正常的suspend/resume */
public void suspendResumeTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="同步代码中使用导致死锁">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */
public void suspendResumeDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				Thread.currentThread().suspend();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		consumerThread.resume();
	}
	System.out.println(&quot;3、通知消费者&quot;);
}

</code></pre>
<h4 id="resume比suspend先执行导致死锁">resume比suspend先执行导致死锁</h4>
<pre><code class="language-java">/** 导致程序永久挂起的suspend/resume */
public void suspendResumeDeadLockTest2() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) {
			System.out.println(&quot;1、没包子，进入等待&quot;);
			try { // 为这个线程加上一点延时
				Thread.sleep(5000L);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// 这里的挂起执行在resume后面
			Thread.currentThread().suspend();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	consumerThread.resume();
	System.out.println(&quot;3、通知消费者&quot;);
	consumerThread.join();
}
</code></pre>
<h3 id="waitnotify机制">wait/notify机制</h3>
<p>基于监视器实现,这些方法只能由<strong>同一对象锁的持有者线程</strong>调用，也就是写在同步块里面，否则会抛出IllegalMonitorStateException异常</p>
<p><strong>wait</strong>方法导致当前线程等待，其实就是将线程加入到对象的等待集合中，并且放弃当前持有的对象锁。</p>
<p><strong>notify/notifyall</strong>方法唤醒一个或所有正在等待这个对象锁的线程。</p>
<p><strong>注意：<strong>虽然会wait自动解锁，但是</strong>对顺序有要求</strong>，如果在 notify被调用之后，才开始wait方法的调用，线程会永远处于 WAITING状态。</p>
<h4 id="正常的waitnotify">正常的wait/notify</h4>
<pre><code class="language-java">/** 正常的wait/notify */
public void waitNotifyTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
			synchronized (this) {
				while (baozidian == null) { // 如果没包子，则进入等待
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h4 id="notify比wait先执行导致死锁">notify比wait先执行导致死锁</h4>
<pre><code class="language-java">/** 会导致程序永久等待的wait/notify */
public void waitNotifyDeadLockTest() throws Exception {
	// 启动线程
	new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			try {
				Thread.sleep(5000L);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
			synchronized (this) {
				try {
					System.out.println(&quot;1、进入等待&quot;);
					this.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	}).start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	synchronized (this) {
		this.notifyAll();
		System.out.println(&quot;3、通知消费者&quot;);
	}
}
</code></pre>
<h3 id="parkunpark机制">park/unpark机制</h3>
<p>线程调用park则等待&quot;许可(permit)&quot;.unpark方法为指定线程提供&quot;许可&quot;</p>
<p>不要求park和unpark方法的调用顺序</p>
<p>多次调用unpark后,再调用park,线程会直接运行,但<strong>许可不会叠加</strong>,</p>
<p>也就是说,连续多次调用park方法,第一次会拿到&quot;许可&quot;直接运行,后续调用依旧会进入等待.</p>
<h4 id="正常的parkunpark">正常的park/unpark</h4>
<pre><code class="language-java">/** 正常的park/unpark */
public void parkUnparkTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		while (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			LockSupport.park();
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	LockSupport.unpark(consumerThread);
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h4 id="同步代码中使用导致死锁-2">同步代码中使用导致死锁</h4>
<pre><code class="language-java">/** 死锁的park/unpark */
public void parkUnparkDeadLockTest() throws Exception {
	// 启动线程
	Thread consumerThread = new Thread(() -&gt; {
		if (baozidian == null) { // 如果没包子，则进入等待
			System.out.println(&quot;1、进入等待&quot;);
			// 当前线程拿到锁，然后挂起
			synchronized (this) {
				LockSupport.park();
			}
		}
		System.out.println(&quot;2、买到包子，回家&quot;);
	});
	consumerThread.start();
	// 3秒之后，生产一个包子
	Thread.sleep(3000L);
	baozidian = new Object();
	// 争取到锁以后，再恢复consumerThread
	synchronized (this) {
		LockSupport.unpark(consumerThread);
	}
	System.out.println(&quot;3、通知消费者&quot;);
}
</code></pre>
<h3 id="伪唤醒">伪唤醒</h3>
<p><code>警告！之前代码中用if语句来判断，是否进入等待状态，是错误的！</code>(上文代码正常的都是使用的while)<br>
官方建议<code>应该在循环中检查等待条件</code>，原因是处于等待状态的线程可能会收到<code>错误警报和伪唤醒</code>，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>伪唤醒是指线程并非因为notify,notifyall,unpark等api调用而唤醒,是更底层原因导致的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CPU缓存和内存屏障]]></title>
        <id>https://www.sunjianbo.com/cpu-cache-and-memory-barrier/</id>
        <link href="https://www.sunjianbo.com/cpu-cache-and-memory-barrier/">
        </link>
        <updated>2020-08-06T03:40:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cpu缓存">CPU缓存</h2>
<p>为了提高程序运行的性能,现代CPU在很多方面对程序进行了优化.</p>
<p>例如:CPU高速缓存.尽可能地避免处理器访问主内存的时间开销,处理器大多会利用缓存(Cache)以提高性能.</p>
<h3 id="多级缓存">多级缓存</h3>
<h4 id="l1-cache一级缓存">L1 Cache(一级缓存)</h4>
<p>CPU第一层高速缓存,分为数据缓存和指令缓存.一般服务器CPU的L1缓存的容量在32---4096KB</p>
<h4 id="l2-cache">L2 Cache</h4>
<p>由于L1级高速缓存容量的限制,为了再次提高CPU的运算速度,在CPU外部放置一高速存储器,即二级缓存</p>
<h4 id="l3-cache">L3 Cache</h4>
<p>现在都是内置的,L3缓存的应用可以进一步降低内存延迟,同时提升大数据量计算时处理器的性能.具有较大L3缓存的处理器能提供更有效的文件系统缓存行为及较短消息和处理器队列长度.一般是多核共享一个L3缓存</p>
<p>CPU在读取数据时,先在L1中寻找,再从L2寻找,再从L3寻找,然后是内存,再后是外存储器(硬盘等)</p>
<h3 id="缓存同步协议">缓存同步协议</h3>
<p>多CPU读取同样的数据进行缓存,进行不同运算之后,最终写入主内存以哪个CPU为准?</p>
<p>在这种高速缓存回写的场景下，有一个缓存一致性协议多数CPU厂商对它进行了实现。</p>
<p><strong>MESI协议</strong>，它规定每条缓存有个状态位，同时定义了下面四个状态:</p>
<ul>
<li>
<p>**修改态（ Modified）😗*此 cache行已被修改过（脏行），内容已不同于主存，为此 cache专有；</p>
</li>
<li>
<p>**专有态（ Exclusive）😗*此 cache行内容同于主存，但不出现于其它 cache中；</p>
</li>
<li>
<p>**共享态（ Shared）😗*此 cache行内容同于主存，但也出现于其它 cacher中；</p>
</li>
<li>
<p>**无效态（ Invalid）😗*此 cache？行内容无效（空行）。</p>
</li>
</ul>
<p>多处理器时，单个CPU对缓存中数据进行了改动，需要通知给其他CPU.</p>
<p>也就是意味着，CPU处理要控制自己的读写操作，还要<strong>监听</strong>其他CPU发出的通知，从而保证<strong>最终一致</strong></p>
<h2 id="cpu指令重排">CPU指令重排</h2>
<h3 id="实例">实例</h3>
<pre><code class="language-java">//代码
x=100;
y=z;
</code></pre>
<p>正常执行的三步骤</p>
<blockquote>
<p>1、将100写入X<br>
2、读取z的值<br>
3、将z值写入y</p>
</blockquote>
<p>重排序后执行</p>
<blockquote>
<p>1、读取z的值<br>
2、将z值写入y<br>
3、将100写入X</p>
</blockquote>
<h3 id="指令重排的场景">指令重排的场景</h3>
<p>当CPU写缓存时发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的读缓存命令优先执行。</p>
<h3 id="as-if-serial">as-if- serial</h3>
<p>并非随便重排，需要遵守as-if- serial语义</p>
<p>as-if- serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。</p>
<p>编译器， runtime和处理器都必须遵守as-if- serial语义。也就是说：编译器和处理器不会对存在数据依赖关系的操作做重排序。</p>
<h2 id="两个问题">两个问题</h2>
<h3 id="cpu高速缓存下的问题">CPU高速缓存下的问题</h3>
<p>缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步。<strong>在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的。</strong></p>
<h3 id="cpu执行指令重排序优化下的问题">CPU执行指令重排序优化下的问题</h3>
<p>虽然遵守了as- if-seriali语义，单仅在<strong>单CPU</strong>自己执行的情况下<strong>能保证结果正确</strong>。<br>
<strong>多核多线程中，指令逻辑无法分辨因果关联，可能出现乱序执行，导致程序运行结果错误。</strong></p>
<h2 id="内存屏障">内存屏障</h2>
<p>为了解決上述两个问题,处理器提供了两个内存屏障指令（ Memory Barrier）</p>
<h3 id="写内存屏障-store-memory-barrier">写内存屏障（ Store Memory Barrier)</h3>
<p>在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。<br>
强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>
<h3 id="读内存屏障-load-memory-barrier">读内存屏障（ Load Memory Barrier.)</h3>
<p>在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据。<br>
强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题</p>
<h2 id="结语">结语</h2>
<p>这个章节是后面<strong>JVM线程安全问题的铺垫</strong>。<br>
同时，也看到了现代CPU不断演进，在程序运行优化中做出的努力。不同CPU厂商所付出的人力物力成本，最终体现在不同CPU性能差距上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[clash for windows升级后发现socks端口合并到7890了]]></title>
        <id>https://www.sunjianbo.com/clash-for-windows-socks-port-7890/</id>
        <link href="https://www.sunjianbo.com/clash-for-windows-socks-port-7890/">
        </link>
        <updated>2020-07-24T01:19:11.000Z</updated>
        <content type="html"><![CDATA[<p>昨天手贱更新了一下订阅,结果不能用了,估计是规则进行了更新,没办法只好升级clash.</p>
<p>新版clash页面大改</p>
<p>升级完之后chrome怎么都上不去,后来仔细一看发现最新版0.11.1只写了一个端口7890</p>
<p>查看发布日志发现在0.10.2版本的时候将端口进行了合并</p>
<blockquote>
<p>migrate to mixed-port from port and socks-port</p>
</blockquote>
<p>虽说一个端口混合了http和socks用起来确实方便了,但是我这样的老用户还真是有点麻烦了,首先要改浏览器插件SwitchyOmega里面的端口,然后还要改Proxifier里面的端口.</p>
<p>关键是要是没注意到端口变化的人还真是要浪费很多的时间来排查问题.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程中止]]></title>
        <id>https://www.sunjianbo.com/thread-abort/</id>
        <link href="https://www.sunjianbo.com/thread-abort/">
        </link>
        <updated>2020-07-17T06:49:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="不推荐的中止方式">不推荐的中止方式</h2>
<h3 id="stop">stop</h3>
<blockquote>
<p>中止线程,并且清除监控器锁的信息,可能导致线程安全文件,jdk不建议使用</p>
</blockquote>
<p>举例说明如何导致线程安全问题:</p>
<p>先定义一个线程,实现i和j同时+1</p>
<pre><code class="language-java">public class StopThread extends Thread {
  private int i = 0, j = 0;

  @Override
  public void run() {
    synchronized (this) {
	    // 增加同步锁，确保线程安全
	    ++i;
	    try {
	      // 休眠10秒,模拟耗时操作
	      Thread.sleep(10000);
	    } catch (InterruptedException e) {
	      e.printStackTrace();
	    }
	    ++j;
    }
  }

  /** * 打印i和j */
  public void print() {
  System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
  }
}
</code></pre>
<p>stop方式中止</p>
<pre><code class="language-java">/**
 * 示例3 - 线程stop强制性中止，破坏线程安全的示例
 */
public class Demo31 {
  public static void main(String[] args) throws InterruptedException {
    StopThread thread = new StopThread();
    thread.start();
    // 休眠1秒，确保i变量自增成功
    Thread.sleep(1000);
    // 暂停线程
    thread.stop(); // 错误的终止
    // thread.interrupt(); // 正确终止
    while (thread.isAlive()) {
      // 确保线程已经终止
    } // 输出结果
    thread.print();
  }
}

</code></pre>
<p>理想输出:i=0 j=0</p>
<p>实际执行结果:i=1 j=0</p>
<p>i没有因中止而回滚,没有保证同步代码块里面的数据一致性,破坏了线程安全</p>
<h3 id="destroy">destroy</h3>
<blockquote>
<p>jdk未实现该方法</p>
</blockquote>
<h2 id="优雅的线程中止">优雅的线程中止</h2>
<h3 id="interrupt">interrupt</h3>
<ul>
<li>
<p>如果目标线程在调用Object class的<code>wait()</code>,<code>wait(long)</code>,<code>wait(long,int)</code>方法,<code>join()</code>,<code>join(long,int)</code>或<code>sleep(long,int)</code>方法时被阻塞,那么interrupt会生效,该线程的中断状态将被清除,抛出InterruptedException异常</p>
</li>
<li>
<p>如果目标线程是被I/O或者NIO中的Channel所阻塞,同样,I/O操作会被中断或者返回特殊异常值.达到终止线程的目的.</p>
</li>
<li>
<p>如果以上条件都不满足,则会设置此线程的中断状态.</p>
</li>
</ul>
<p>复用上面的例子,将其中的<code>thread.stop();</code>改为<code>thread.interrupt();</code>查看执行结果:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611104339183.png" alt="" loading="lazy"></figure>
<p>结果i=1 j=1保证了数据一致性,同时抛出一个InterruptedException异常来给开发者进行对应处理</p>
<h3 id="标志位">标志位</h3>
<p>代码逻辑中,增加一个判断,用来控制线程的中止.</p>
<p>如下示例,设置一个flag,通过外部修改flag的值来让while条件不满足跳出循环以使线程继续运行到结束:</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程状态]]></title>
        <id>https://www.sunjianbo.com/thread-state/</id>
        <link href="https://www.sunjianbo.com/thread-state/">
        </link>
        <updated>2020-07-03T01:47:48.000Z</updated>
        <content type="html"><![CDATA[<p>线程有6个状态,可以查看java.lang.Thread.State</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>New</td>
<td>尚未启动的线程的线程状态</td>
</tr>
<tr>
<td>Runnable</td>
<td>可运行线程的线程状态,等待CPU调度</td>
</tr>
<tr>
<td>Blocked</td>
<td>线程阻塞等待监视器锁定的线程状态</td>
</tr>
<tr>
<td>Waiting</td>
<td>等待线程的线程状态.下列不带超时的方式:<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.park</code></td>
</tr>
<tr>
<td>Timed Waiting</td>
<td>具有制定等待时间的等待线程的线程状态.下列带超时的方式:<code>Thread.sleep</code>,<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.parkNanos</code>,<code>LockSupport.parkUntil</code></td>
</tr>
<tr>
<td>Terminated</td>
<td>终止线程的线程状态,线程正常完成执行或者出现异常</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200611094432936.png" alt="states" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 多线程运行状态切换示例 &lt;br/&gt;
 */
public class Demo2 {
	public static Thread thread1;
	public static Demo2 obj;

	public static void main(String[] args) throws Exception {
		// 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
		System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
		Thread thread1 = new Thread(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread1 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
		thread1.start();
		Thread.sleep(2000L); // 等待thread1执行结束，再看状态
		System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
		// thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

		System.out.println();
		System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
		Thread thread2 = new Thread(new Runnable() {
			@Override
			public void run() {
				try {// 将线程2移动到等待状态，1500后自动唤醒
					Thread.sleep(1500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
				System.out.println(&quot;thread2 执行了&quot;);
			}
		});
		System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		thread2.start();
		System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(200L); // 等待200毫秒，再看状态
		System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
		Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
		System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

		System.out.println();
		System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
		Thread thread3 = new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (Demo2.class) {
					System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
					System.out.println(&quot;thread3 执行了&quot;);
				}
			}
		});
		synchronized (Demo2.class) {
			System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			thread3.start();
			System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
			Thread.sleep(200L); // 等待200毫秒，再看状态
			System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
		}
		Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
		System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread2.getState().toString());

	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA程序运行原理分析]]></title>
        <id>https://www.sunjianbo.com/jvm-operation-principle/</id>
        <link href="https://www.sunjianbo.com/jvm-operation-principle/">
        </link>
        <updated>2020-07-02T03:08:07.000Z</updated>
        <content type="html"><![CDATA[<p>我的理解JVM内存结构就是程序由字节码文件读入到jvm中解析存储到执行所需要的一些东西</p>
<h2 id="class文件内容">class文件内容</h2>
<p>class文件包含JAVA程序执行的字节码;数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符;文件开头有一个0xcafebabe(16进制)特殊的一个标志.</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200610134740885.png" alt="class" loading="lazy"></figure>
<p>class文件内存储的是指令码</p>
<h2 id="jvm运行时数据区">JVM运行时数据区</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200610141943161.png" alt="jvm" loading="lazy"></figure>
<h3 id="线程共享">线程共享</h3>
<h4 id="方法区">方法区</h4>
<p>jvm用来存储加载的类信息,常量,静态变量,编译后的代码等数据.</p>
<p>这是虚拟机中的一个逻辑区划,具体实现根据不同虚拟机来实现.</p>
<p>如:oracle的HotSpot在java7中方法区放在永久代,java8放在元数据空间,并且通过GC机制对这个区域进行管理</p>
<h4 id="堆内存">堆内存</h4>
<p>堆内存是VM启动时创建,用于存放对象的实例.</p>
<p>还可以细分为:老年代,新生代(Eden,From Survivor,To Survivor).</p>
<p>垃圾回收器主要就是管理堆内存.</p>
<p>如果满了,就会出现OutOfMemoryError</p>
<h2 id="线程独享">线程独享</h2>
<h4 id="虚拟机栈">虚拟机栈</h4>
<p>每个线程都在这个空间又一个私有的空间.</p>
<p>线程栈由多个栈帧组成.</p>
<p>一个线程会执行一个或多个方法,一个方法对应一个栈帧.</p>
<p><strong>栈帧内容包含:局部变量表,操作数栈,动态链接,方法返回地址,附加信息等.</strong></p>
<p>栈内存默认最大是<strong>1M</strong>.超出则抛出StackOverFlowError</p>
<h4 id="本地方法栈">本地方法栈</h4>
<p>和虚拟机栈功能类似,不同的是虚拟机栈是为虚拟机执行java方法而准备的,本地方法栈是为虚拟机使用Native本地方法而准备的.</p>
<p>虚拟机规范没有规定具体的实现,由不同的虚拟机厂商去实现.</p>
<p>HotSpot虚拟机中的虚拟机栈和本地方法栈的实现是一样的.同样,超出大小以后也会抛出StackOverFlowError</p>
<h4 id="程序计数器program-counter-register">程序计数器(Program Counter Register)</h4>
<p>记录当前线程执行字节码的位置,存储的是字节码指令地址.</p>
<p>如果执行Native方法,则计数器值为空.</p>
<p>每个线程都在这个空间有一个私有的空间,占用内存空间很少.</p>
<p>CPU同一时间只会执行一条线程中的指令.JVM多线程会轮流切换并分配CPU执行时间.在线程切换后,需要通过程序计数器来恢复正确的执行位置.</p>
]]></content>
    </entry>
</feed>