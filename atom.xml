<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.sunjianbo.com</id>
    <title>孙建博的小站</title>
    <updated>2020-07-02T03:33:46.731Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.sunjianbo.com"/>
    <link rel="self" href="https://www.sunjianbo.com/atom.xml"/>
    <subtitle>互联网、编程、生活感悟，在这里希望你我都能有所收获，得到提升</subtitle>
    <logo>https://www.sunjianbo.com/images/avatar.png</logo>
    <icon>https://www.sunjianbo.com/favicon.ico</icon>
    <rights>All rights reserved 2020, 孙建博的小站</rights>
    <entry>
        <title type="html"><![CDATA[1.1.1 JAVA程序运行原理分析]]></title>
        <id>https://www.sunjianbo.com/jvm-operation-principle/</id>
        <link href="https://www.sunjianbo.com/jvm-operation-principle/">
        </link>
        <updated>2020-07-02T03:08:07.000Z</updated>
        <content type="html"><![CDATA[<p>我的理解JVM内存结构就是程序由字节码文件读入到jvm中解析存储到执行所需要的一些东西</p>
<h2 id="class文件内容">class文件内容</h2>
<p>class文件包含JAVA程序执行的字节码;数据严格按照格式紧凑排列在class文件中的二进制流,中间无任何分隔符;文件开头有一个0xcafebabe(16进制)特殊的一个标志.</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/image-20200610134740885.png" alt="class" loading="lazy"></figure>
<p>class文件内存储的是指令码</p>
<h2 id="jvm运行时数据区">JVM运行时数据区</h2>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/image-20200610141943161.png" alt="jvm" loading="lazy"></figure>
<h3 id="线程共享">线程共享</h3>
<h4 id="方法区">方法区</h4>
<p>jvm用来存储加载的类信息,常量,静态变量,编译后的代码等数据.</p>
<p>这是虚拟机中的一个逻辑区划,具体实现根据不同虚拟机来实现.</p>
<p>如:oracle的HotSpot在java7中方法区放在永久代,java8放在元数据空间,并且通过GC机制对这个区域进行管理</p>
<h4 id="堆内存">堆内存</h4>
<p>堆内存是VM启动时创建,用于存放对象的实例.</p>
<p>还可以细分为:老年代,新生代(Eden,From Survivor,To Survivor).</p>
<p>垃圾回收器主要就是管理堆内存.</p>
<p>如果满了,就会出现OutOfMemoryError</p>
<h2 id="线程独享">线程独享</h2>
<h4 id="虚拟机栈">虚拟机栈</h4>
<p>每个线程都在这个空间又一个私有的空间.</p>
<p>线程栈由多个栈帧组成.</p>
<p>一个线程会执行一个或多个方法,一个方法对应一个栈帧.</p>
<p><strong>栈帧内容包含:局部变量表,操作数栈,动态链接,方法返回地址,附加信息等.</strong></p>
<p>栈内存默认最大是<strong>1M</strong>.超出则抛出StackOverFlowError</p>
<h4 id="本地方法栈">本地方法栈</h4>
<p>和虚拟机栈功能类似,不同的是虚拟机栈是为虚拟机执行java方法而准备的,本地方法栈是为虚拟机使用Native本地方法而准备的.</p>
<p>虚拟机规范没有规定具体的实现,由不同的虚拟机厂商去实现.</p>
<p>HotSpot虚拟机中的虚拟机栈和本地方法栈的实现是一样的.同样,超出大小以后也会抛出StackOverFlowError</p>
<h4 id="程序计数器program-counter-register">程序计数器(Program Counter Register)</h4>
<p>记录当前线程执行字节码的位置,存储的是字节码指令地址.</p>
<p>如果执行Native方法,则计数器值为空.</p>
<p>每个线程都在这个空间有一个私有的空间,占用内存空间很少.</p>
<p>CPU同一时间只会执行一条线程中的指令.JVM多线程会轮流切换并分配CPU执行时间.在线程切换后,需要通过程序计数器来恢复正确的执行位置.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[activemq启动报错Failed to connect to the Wrapper at port 32000]]></title>
        <id>https://www.sunjianbo.com/activemq-wrapper-error/</id>
        <link href="https://www.sunjianbo.com/activemq-wrapper-error/">
        </link>
        <updated>2020-05-06T08:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<blockquote>
<p>win7 x64</p>
<p>java1.8.0_20</p>
<p>activemq:5.15.12(当前最新)</p>
</blockquote>
<h2 id="报错信息">报错信息</h2>
<p>运行<code>apache-activemq\bin\win64\activemq.bat</code>报如下错误:</p>
<pre><code>jvm 1    | Failed to connect to the Wrapper at port 32000.
jvm 1    | java.net.ConnectException: connect: Address is invalid on local machine, or port is not valid on remote machine
jvm 1    | Exiting JVM...
</code></pre>
<p>编辑<code>win64</code>目录下<code>wrapper.conf</code>文件,取消注释</p>
<pre><code># wrapper.debug=TRUE
</code></pre>
<hr>
<p>title: 'activemq启动报错Failed to connect to the Wrapper at port 32000'<br>
date: 2020-05-06 16:36:28<br>
tags: [activemq,wrapper,报错]<br>
published: true<br>
hideInList: false<br>
feature:<br>
isTop: false</p>
<hr>
<pre><code>INFO   | jvm 1    | 2020/05/06 16:26:52 | Load native library.  One or more attempts may fail if platform specific libraries do not exist.
INFO   | jvm 1    | 2020/05/06 16:26:52 | Loading native library failed: wrapper-windows-x86-64.dll  Cause: java.lang.UnsatisfiedLinkError: no wrapper-windows-x86-64 in java.library.path
</code></pre>
<h2 id="试图解决">试图解决</h2>
<p>根据以上两个关键信息进行Google,然而崩溃的是股沟了好久没有找到解决方法</p>
<p>期间尝试了网上说的修改<code>conf/activemq.xml</code>与<code>conf/jetty.xml</code>配置文件中的ip<code>0.0.0.0</code>改为<code>127.0.0.1</code></p>
<p>修改<code>wrapper.conf</code>文件中的<code>wrapper.java.command=java</code>为指定<code>jdkpath\bin\java</code></p>
<p>均无效,最后放弃这种启动方式,改为下面方式启动.没有报错</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>双击运行<code>apache-activemq\bin\win6\InstallService.bat</code>以安装服务</p>
<p><code>win+r</code>启动<code>cmd</code>输入:</p>
<pre><code>net start activemq
</code></pre>
<p>完全没报错,顺利启动</p>
<p>浏览器打开<a href="http://127.0.0.1:8161">http://127.0.0.1:8161</a></p>
<p>成功访问</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hp chromebook 11 G1通过crouton安装及使用Debian]]></title>
        <id>https://www.sunjianbo.com/chromebook-crouton-linux/</id>
        <link href="https://www.sunjianbo.com/chromebook-crouton-linux/">
        </link>
        <updated>2020-04-24T06:31:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一关于备份">一.关于备份</h2>
<p>在操作之前本来应该是备份的,但是考虑到官方提供救砖的方法(<a href="https://support.google.com/chromebook/answer/1080595?hl=zh-Hans">https://support.google.com/chromebook/answer/1080595?hl=zh-Hans</a>),也就先放心的直接上手安装了.(主要原因其实是没有u盘(◔◡◔))</p>
<h2 id="二进入开发者模式">二.进入开发者模式</h2>
<p>同时按住<code>esc + refresh + power</code></p>
<p>然后自动重启,提示你系统已经损坏,好了结束了,可以卖破烂了(◔◡◔)</p>
<p>当然不会这样,再按一下<code>ctrl+D</code>提示关闭系统验证,再按Enter,提示验证已关闭,继续<code>ctrl+D</code>*2</p>
<p>最后系统开始为了进入开发者模式准备一些东西,需要等待几分钟.</p>
<p>准备完成重启之后,就始终需要按<code>ctrl+D</code>来进入chromeOS了</p>
<h2 id="三下载crouton">三.下载crouton</h2>
<p>crouton项目的github:<a href="https://github.com/dnschneid/crouton">https://github.com/dnschneid/crouton</a></p>
<p>在Usage内容下有个下载地址,这里直接贴出来了:<a href="https://goo.gl/fd3zc">https://goo.gl/fd3zc</a></p>
<p>下载下来应该默认存储在</p>
<h2 id="四打开shell">四.打开shell</h2>
<p><code>ctrl+alt+t</code>打开一个命令行,这是chrome的crosh,再输入<code>shell</code>回车进入linux shell</p>
<h2 id="五安装linux">五.安装linux</h2>
<p>因为配置垃圾,所以选择了debian buster+lxde桌面,在这之前我查看了一下剩余空间<strong>9.2G</strong></p>
<pre><code class="language-shell">sudo sh crouton -r buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<p><code>-P</code> 参数是用来指定翻墙代理的,下面命令可以查看所有可安装的linux</p>
<pre><code class="language-shell">sudo sh crouton -t list -P http://127.0.0.1:7890
</code></pre>
<h3 id="中间因为网络问题失败了一次再次安装会报错">中间因为网络问题失败了一次,再次安装会报错:</h3>
<blockquote>
<p>/usr/local/chroots/buster already has stuff in it!<br>
Either delete it, specify a different name (-n), or specify -u to update it.</p>
</blockquote>
<p>根据提示使用以下命令才能继续</p>
<pre><code>sudo sh crouton -u -n buster -t lxde -P http://127.0.0.1:7890
</code></pre>
<h3 id="安装耗时1410-1701接近三小时公司垃圾网下载速度不到100下载文件500m左右安装完成后第一次启动后剩余空间76g即占用16g">安装耗时14.10-17.01接近三小时,公司垃圾网下载速度不到100,下载文件500M左右,安装完成后第一次启动后剩余空间7.6G,即占用1.6G</h3>
<h3 id="启动linux">启动linux</h3>
<pre><code>sudo startlxde
</code></pre>
<h2 id="六备份回复删除系">六.备份/回复/删除系</h2>
<p>备份命令:</p>
<pre><code>sudo edit-chroot -b buster -f ~/Downloads/buster-backup.bak
</code></pre>
<p>恢复:</p>
<pre><code>sudo sh -e ~/Downloads/crouton -f ~/Downloads/buster-backup.bak
</code></pre>
<p>删除</p>
<pre><code>sudo delete-chroot buster
</code></pre>
<p>或者</p>
<pre><code>sudo edit-chroot -d buster
</code></pre>
<h2 id="七使用">七.使用:</h2>
<h3 id="1不启动整个linux只启动其shell">1.不启动整个linux只启动其shell:</h3>
<pre><code>sudo enter-chroot
</code></pre>
<h3 id="2系统任意切换">2.系统任意切换</h3>
<blockquote>
<p>shift+ctrl+alt+前进键(F2)/后退键(F1)</p>
</blockquote>
<p>不是说后退切换过去然后前进切换回来,而是只要用一个组合键就可以来回切换,按一下切换再按一下切换回来</p>
<h3 id="3安装后系统配置">3.安装后系统配置</h3>
<p>参考这篇文章:<a href="https://frapples.github.io/articles/2017-05-11-e6dc.html">https://frapples.github.io/articles/2017-05-11-e6dc.html</a></p>
<h3 id="4安装clash">4.安装clash</h3>
<p>chrome的shadowsocks插件比较老,很多新的加密协议都不支持,所以我之前都是走局域网的代理,装好clash就可以自给自足了</p>
<p>完整教程:<a href="https://ssu.tw/index.php/archives/37/">https://ssu.tw/index.php/archives/37/</a></p>
<pre><code>cd ~
sudo mkdir clash //创建目录
cd clash //切换至此目录
sudo wget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-armv7-v0.19.0.gz //下载D大预编译好的包
sudo gunzip clash-linux-armv7-v0.19.0.gz //解压，记得可以使用Tab键补全，得到clash的二进制
sudo mv clash-linux-armv7-v0.19.0 /usr/local/bin/clash //移动并重命名，简短方便使用
sudo chmod +x /usr/local/bin/clash //赋予此文件可执行权限
</code></pre>
<p>下载配置文件样例</p>
<pre><code>sudo wget https://raw.githubusercontent.com/ConnersHua/Profiles/master/Clash/Pro.yaml //下载范例配置文件
sudo mv Pro.yaml config.yaml //重命名
</code></pre>
<p>修改配置文件</p>
<pre><code>sudo vim config.yaml //编辑此配置文件

# 这里建议从false改为true，允许局域网共享
allow-lan: true

# 下面这行，建议取消前面#注释符号
bind-address: &quot;*&quot;

# RESTful API for clash
# 修改外部控制，将127.0.0.1改为0.0.0.0
external-controller: 0.0.0.0:9090
</code></pre>
<p>启动clash</p>
<pre><code>clash -d ~/clash
</code></pre>
<p>clash启动之后，你可以用局域网的设备访问<code>http://clash.razord.top</code>， 然后Host填写你树莓派在局域网中的IP地址，端口填写上面设置的9090，即可访问成功。</p>
<h3 id="5安装typora失败">5.安装Typora(失败)</h3>
<p>因为本来搞个chromebook定位就是用来写文档的,所以安装自己用习惯的md编辑器Typora,方法参考<a href="https://support.typora.io/Typora-on-Linux/">官方文档</a></p>
<pre><code class="language-shell">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -
sudo add-apt-repository 'deb https://typora.io/linux ./'
# 若报错 add-apt-repository: command not found则先执行:sudo apt-get install software-properties-common
sudo apt-get update
sudo apt-get install typora
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git push error dst refspec "XXX" matches more than one]]></title>
        <id>https://www.sunjianbo.com/git-push-matches-more-than-one/</id>
        <link href="https://www.sunjianbo.com/git-push-matches-more-than-one/">
        </link>
        <updated>2020-04-15T04:36:08.000Z</updated>
        <content type="html"><![CDATA[<p>今天在2.1.2分支上修改完xxl-job的数据库为oracle之后想要提交,结果报错</p>
<h3 id="报错信息">报错信息</h3>
<blockquote>
<p>Failed with error: HttpRequestException encountered. dst refspec 2.1.2 matches more than one. failed to push some refs to 'https://github.com/sunjianbo/xxl-job.git'</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/1586921186771_17.png" alt="error" loading="lazy"></figure>
<h3 id="原因">原因</h3>
<p>翻译一下就是你想要提交到的目标不只存在一个,git不知道你要提交到哪一个了<br>
那么分支名称肯定是不会出现重复的,那就只可能是分支名和tag名冲突了</p>
<pre><code>$ git tag
</code></pre>
<p>查看发现果然也存在一个叫做2.1.2的tag</p>
<h3 id="解决方案">解决方案</h3>
<p>删除本地标签</p>
<pre><code>$ git tag -d 2.1.2
</code></pre>
<p>删除远程标签</p>
<pre><code>$ git push origin :refs/tags/2.1.2
</code></pre>
<p>顺利提交<br>
<img src="https://static.sunjianbo.com/1586921495457_18.png" alt="pushed" loading="lazy"></p>
<p>附git tag常用操作速查:</p>
<p><a href="https://blog.csdn.net/happycxz/article/details/78893690">https://blog.csdn.net/happycxz/article/details/78893690</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手动修改xxl-job-admin以支持Oracle数据库]]></title>
        <id>https://www.sunjianbo.com/xxl-job-oracle/</id>
        <link href="https://www.sunjianbo.com/xxl-job-oracle/">
        </link>
        <updated>2020-04-14T08:31:33.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基于xxl-job-2.1.2.Release</p>
</blockquote>
<p>直接使用:<a href="https://github.com/sunjianbo/xxl-job/tree/2.1.2">https://github.com/sunjianbo/xxl-job/tree/2.1.2</a></p>
<h2 id="docdbtables_xxl_jobsql">doc/db/tables_xxl_job.sql</h2>
<p>根据文件内容将其中的mysql语法修改为oracle</p>
<p>这里是我已改好的2.1.2版本对应的oracle文件:<a href="https://static.sunjianbo.com/code/sql/tables_xxl_job_oracle.sql">下载</a></p>
<h2 id="pomxml">/pom.xml</h2>
<p>注释</p>
<pre><code class="language-xml">&lt;!-- mysql --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;${mysql-connector-java.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>替换为</p>
<pre><code class="language-xml">&lt;!-- oracle --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.oracle&lt;/groupId&gt;
    &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;
    &lt;version&gt;11.2.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>根据自己的oracle本版选择对应的jdbc</p>
<blockquote>
<p>查看本版SQL:	<code>select version from v$instance;</code></p>
</blockquote>
<h2 id="srcmainresourcesapplicationproperties">/src/main/resources/application.properties</h2>
<p>注释</p>
<pre><code>#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8
#spring.datasource.driver-class-name=com.mysql.jdbc.Driver
#spring.datasource.tomcat.validation-query=SELECT 1
</code></pre>
<p>替换为</p>
<pre><code>spring.datasource.url=jdbc:oracle:thin:@127.0.0.1:3306:1521/xxl_job
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.datasource.tomcat.validation-query=SELECT 1 FROM DUAL
</code></pre>
<h2 id="srcmainresourcesmybatis-mapper">/src/main/resources/mybatis-mapper</h2>
<ul>
<li>查找mybatis-mapper目录下的所有</li>
</ul>
<pre><code>`
</code></pre>
<p>符号,替换为空</p>
<ul>
<li>查找</li>
</ul>
<pre><code>AS t
</code></pre>
<p>替换为t,搜索AS大写区分或者words</p>
<ul>
<li>查找</li>
</ul>
<pre><code>;
</code></pre>
<p>符号,替换为空</p>
<h2 id="srcmainresourcesmybatis-mapperxxljobgroupmapperxml">/src/main/resources/mybatis-mapper/XxlJobGroupMapper.xml</h2>
<p>将其中</p>
<pre><code>t.`order`
</code></pre>
<p>以及</p>
<pre><code>t.order
</code></pre>
<p>替换为</p>
<pre><code>t.&quot;ORDER&quot;
</code></pre>
<p>ORDER必须大写</p>
<h2 id="srcmainresourcesmybatis-mapperxxljobloggluemapperxml">/src/main/resources/mybatis-mapper/XxlJobLogGlueMapper.xml</h2>
<p>去掉select 出的<code>,rownum rn</code>将<code>where rn</code>改为<code>where rownum</code></p>
<p>修改后的代码:</p>
<pre><code>&lt;delete id=&quot;removeOld&quot; &gt;
   DELETE FROM xxl_job_logglue
   WHERE id NOT in(
      SELECT id FROM(
         SELECT id FROM xxl_job_logglue
         WHERE job_id = #{jobId}
         ORDER BY update_time desc
      ) t1 where rownum  &lt;![CDATA[ &lt;= ]]&gt;  #{limit}
   ) AND job_id = #{jobId}
&lt;/delete&gt;
</code></pre>
<h2 id="其他mapperxml">其他Mapper.xml</h2>
<ul>
<li>save的自增id修改为oracle格式</li>
<li>LIMIT的修改为oracle的rownum</li>
<li>增加jdbcType以防空值报错</li>
</ul>
<p><strong>注意:</strong></p>
<p>如果加jdbcType的话,XxlJobInfoMapper.xml中有两个属性写的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">{executorTimeout}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span></span></span></span></span>{executorFailRetryCount},注意改成#{}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[telegram频道发布增加点赞评论等反馈功能]]></title>
        <id>https://www.sunjianbo.com/telegram-add-reactions/</id>
        <link href="https://www.sunjianbo.com/telegram-add-reactions/">
        </link>
        <updated>2020-04-01T02:57:10.000Z</updated>
        <content type="html"><![CDATA[<p>我自己经营了一个telegram的订阅频道:<a href="https://t.me/alittlefun">有点意思@alittlefun</a>用来分享一些有意思的图片什么的.</p>
<p>之前看到别人的订阅频道有emojies的点赞功能,觉得很好,类似这样:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/20200331110800.png" alt="" loading="lazy"></figure>
<p>所以想要放到自己频道来用,但是上网找了一圈只找到一个@like机器人可以满足我的要求,原文:<a href="http://x.2129.n8.nabble.com/Telegram-td30.html">http://x.2129.n8.nabble.com/Telegram-td30.html</a></p>
<p>但是它有一个问题,就是发出来的内容是通过转发方式出来的,这样就会在上面有个标志:</p>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/20200331111030.png" alt="" loading="lazy"></figure>
<p>处女座的我哪受得了这个啊.于是绞尽脑汁一顿折腾,终于找到了方法(＾－＾)V</p>
<h2 id="1使用botfather创建一个发布bot">1.使用@BotFather创建一个发布bot</h2>
<p>搜索到@BotFather --&gt; <code>/start</code> --&gt; <code>/newbot</code> --&gt; 输入自定义id --&gt; 输入自定义username</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/20200331111841.png" alt="step1" loading="lazy"></figure>
<h2 id="2使用controllerbot-新增并管理频道">2.使用@ControllerBot 新增并管理频道</h2>
<h3 id="21搜索到controllerbot-start-addchannel-复制上图标红位置的在botfather创建的token到controllerbot-粘贴">2.1搜索到@ControllerBot --&gt; <code>/start</code> --&gt; <code>/addchannel</code>--&gt; 复制上图标红位置的在BotFather创建的token到ControllerBot 粘贴</h3>
<figure data-type="image" tabindex="4"><img src="https://static.sunjianbo.com/20200331112452.png" alt="addchannel" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://static.sunjianbo.com/20200331112830.png" alt="token" loading="lazy"></figure>
<h3 id="22按照提示到自己的频道去把刚刚创建的bot增加为管理员">2.2按照提示到自己的频道去把刚刚创建的bot增加为管理员</h3>
<p>自己频道右上角Manage Channel --&gt; 点击Administrators --&gt; 点击左下角ADD ADMINISTRATOR --&gt; 搜索刚刚创建的bot(eg:alittlefun_bot)--&gt;完成管理员添加</p>
<h3 id="23转发一条自己频道的信息给controllerbot">2.3转发一条自己频道的信息给@ControllerBot</h3>
<h3 id="24输入城市名来确定时区直接输入shanghai">2.4输入城市名来确定时区,直接输入<code>shanghai</code></h3>
<figure data-type="image" tabindex="6"><img src="https://static.sunjianbo.com/20200331113549.png" alt="" loading="lazy"></figure>
<h3 id="25设置完成">2.5设置完成</h3>
<h2 id="3发布内容">3.发布内容</h2>
<h3 id="31点击上图create-post按钮或者手动打开之前创建的机器人alittlefun_bot-start-发送内容">3.1点击上图<strong>Create Post</strong>按钮或者手动打开之前创建的机器人(@alittlefun_bot) --&gt; <code>/start</code> --&gt; 发送内容</h3>
<figure data-type="image" tabindex="7"><img src="https://static.sunjianbo.com/20200331131340.png" alt="" loading="lazy"></figure>
<h3 id="32点击add-reactions按钮发送需要的emoji表情过去">3.2点击<strong>Add Reactions</strong>按钮,发送需要的emoji表情过去</h3>
<h3 id="33最后点击文本框下面send按钮设定发送时机参考图片">3.3最后点击文本框下面Send按钮,设定发送时机(参考图片)</h3>
<figure data-type="image" tabindex="8"><img src="https://static.sunjianbo.com/20200331132137.png" alt="" loading="lazy"></figure>
<h2 id="4总结">4.总结</h2>
<p>经过以上步骤即可实现在自己的频道发布带emoji点赞反馈的内容.</p>
<p>步骤可以简单归纳为</p>
<ol>
<li>
<p>@BotFather创建自定义bot</p>
</li>
<li>
<p>@ControllerBot绑定自定义bot和频道</p>
</li>
<li>
<p>在自定义bot发布内容</p>
</li>
</ol>
<p>同时细心的小伙伴一定也发现了通过这个bot还可以实现<strong>附加媒体</strong>,<strong>增加评论</strong>,<strong>附加URL</strong>以及<strong>定时发送</strong>的功能,都可以自行研究一下.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Typora侧边栏文件列表排序-按修改时间]]></title>
        <id>https://www.sunjianbo.com/typora-file-sort/</id>
        <link href="https://www.sunjianbo.com/typora-file-sort/">
        </link>
        <updated>2020-03-31T02:49:30.000Z</updated>
        <content type="html"><![CDATA[<p>Typora侧边栏文件视图默认排序方式是自然排序,即按照数字或者首字母顺序排序.</p>
<p>但是我自己用起来很不方便,比如我新建一个文件,重命名之后就会被排序到列表中间某个位置,不太好找.</p>
<p>所以想要按照修改时间倒序,这样新建的文件就在最上面了.</p>
<p>一开始右键菜单里找了半天没找到,后来才发现<strong>在列表的最下面</strong>.</p>
<p>非常简单如图操作,<strong>切换升序降序只需要再多点击一次图标就行</strong>:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/20200331104630.png" alt="click" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/20200331104806.png" alt="sort" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[github pages url重定向的变相解决方法]]></title>
        <id>https://www.sunjianbo.com/github-pages-rewrite/</id>
        <link href="https://www.sunjianbo.com/github-pages-rewrite/">
        </link>
        <updated>2020-03-12T02:07:10.000Z</updated>
        <content type="html"><![CDATA[<p>这也是从WordPress迁移到Gridea&amp;github pages的后遗症之一.</p>
<p>我在WP那边的url格式是https://www.sunjianbo.com/xxx.html,而弄好Gridea之后发现url格式是https://www.sunjianbo.com/post/xxx/.因为是老站嘛,搜索引擎还是有一些关键词可以搜到的,所以昨天发现了问题,从搜索引擎那边链接打开的页面都会404.</p>
<p>我第一个想法就是通过.htaccess做url的rewrite,但是搜索一下发现github pages并不支持这种方式.</p>
<p>好在还知道<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2; url='/'&quot;&gt;</code>标签可以做页面的定时跳转和刷新,再结合使用<code>&lt;link rel=&quot;canonical&quot; href=&quot;&quot; /&gt;</code>标签来告诉搜索引擎新的规范链接地址.</p>
<p>思路说完了,那么以下是详细步骤:</p>
<h2 id="1修改gridea主题设置">1.修改Gridea主题设置</h2>
<p>开启,精简url模式这是为了去掉url中的/post/,不用gridea的可以无视.<img src="https://static.sunjianbo.com/20200312102504.png" alt="gridea" loading="lazy"></p>
<h2 id="2批量创建html文件">2.批量创建html文件</h2>
<p>我这里通过Python代码遍历post目录下所有文章,提取文件名,替换后缀名,在指定目录生成.html文件.</p>
<p>代码如下:</p>
<pre><code class="language-Python">#conding=utf8
import os
g = os.walk(&quot;D:\IDE\Gridea\Documents\Gridea\posts&quot;)
out = &quot;D:\IDE\Gridea\Documents\Gridea\output\&quot;
for path,dir_list,file_list in g:
    print(len(file_list))
    for file_name in file_list:
        # print(os.path.join(path, file_name) )

        print(os.path.splitext(file_name)[0])
        outName = os.path.splitext(file_name)[0] + &quot;.html&quot;
        with open(out + outName, 'w') as f:  # open()函数可以判断文件是否存在，如果不存在，则创建文件
            myurl = &quot;www.sunjianbo.com/&quot; +os.path.splitext(file_name)[0]
            message = &quot;&quot;&quot;&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=https://myurl/&quot;&gt;
    &lt;link rel=&quot;canonical&quot; href=&quot;https://myurl/&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;&quot;&quot;&quot;
            message = message.replace(&quot;myurl&quot;,myurl)
            f.write(message)
</code></pre>
<h2 id="3上传到github">3.上传到github</h2>
<p>打开.html查看是否没有问题,删除多余的没用文件,比如我这里还生成了一个<code>.DS_Store.html</code>*´∀`)</p>
<p>然后手动上传到github,不能通过Gridea上传因为他会清空output目录自己再生成一遍文章,我们的html文件会在同步前被删除.</p>
<p>到output目录打开终端</p>
<pre><code class="language-git">git add .
git commit -m &quot;for rewrite&quot;
git pustt
</code></pre>
<p>当然网页上传也可以,不过上传文件限制一次100,文章多的话更麻烦一点.</p>
<h2 id="4最后到搜索引擎搜索关键字测试一下吧">4.最后到搜索引擎搜索关键字测试一下吧.</h2>
<h2 id="ps可以将html文件上传github的不同目录来满足不同url格式的支持">PS:可以将.html文件上传github的不同目录来满足不同url格式的支持.</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea主题修改之自动摘要]]></title>
        <id>https://www.sunjianbo.com/gridea-auto-excerpt/</id>
        <link href="https://www.sunjianbo.com/gridea-auto-excerpt/">
        </link>
        <updated>2020-03-11T06:42:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Gridea的部分主题并不带有自动摘要功能,如果需要摘要得先在文章中手动插入<code>&lt;!--more--&gt;</code>标记.否则首页就是光溜溜的一片标题,看起来很不舒服.</p>
<p>而且像我这样直接从WordPress迁移很多文章过来的也不可能挨篇文章去加<code>&lt;!--more--&gt;</code>标记,所以动手修改主题以达到首页自动显示摘要的目的.</p>
<p>本文以Gridea自带主题&lt;Simple1.1.0&gt;为例,讲述如何通过js代码修改添加自定义配置并完成自动摘要功能,修改方法大同小异,其他主题也可以参考.</p>
]]></summary>
        <content type="html"><![CDATA[<p>Gridea的部分主题并不带有自动摘要功能,如果需要摘要得先在文章中手动插入<code>&lt;!--more--&gt;</code>标记.否则首页就是光溜溜的一片标题,看起来很不舒服.</p>
<p>而且像我这样直接从WordPress迁移很多文章过来的也不可能挨篇文章去加<code>&lt;!--more--&gt;</code>标记,所以动手修改主题以达到首页自动显示摘要的目的.</p>
<p>本文以Gridea自带主题&lt;Simple1.1.0&gt;为例,讲述如何通过js代码修改添加自定义配置并完成自动摘要功能,修改方法大同小异,其他主题也可以参考.</p>
<!--more-->
<h2 id="1增加自定义配置">1.增加自定义配置</h2>
<p>编辑文件<code>%Gridea%\themes\simple\config.json</code>,<code>%Gridea%</code>就是Gridea设置中的站点源文件路径.</p>
<p>在合适的位置上添加以下代码:</p>
<pre><code class="language-js">	{
      &quot;name&quot;: &quot;is_auto_excerpt&quot;,
      &quot;label&quot;: &quot;是否启用自动摘要&quot;,
      &quot;group&quot;: &quot;自动摘要&quot;,
      &quot;value&quot;: true,
      &quot;type&quot;: &quot;switch&quot;
    },
    {
      &quot;name&quot;: &quot;auto_excerpt_line&quot;,
      &quot;label&quot;: &quot;自动摘要选取行数&quot;,
      &quot;group&quot;: &quot;自动摘要&quot;,
      &quot;value&quot;: &quot;3&quot;,
      &quot;type&quot;: &quot;input&quot;
    },
</code></pre>
<p>就完成了主题的页面设置功能,自动摘要选取的行数可以自定义</p>
<p>效果图:</p>
<figure data-type="image" tabindex="1"><img src="https://static.sunjianbo.com/gridea-auto-excerpt/image-20200311142153575.png" alt="image-20200311142153575" loading="lazy"></figure>
<h2 id="2首页编写自动摘要功能">2.首页编写自动摘要功能</h2>
<p>编辑文件<code>%Gridea%\themes\simple\templates\index.ejs</code>在如图所示位置添加代码:</p>
<figure data-type="image" tabindex="2"><img src="https://static.sunjianbo.com/gridea-auto-excerpt/image-20200311142947299.png" alt="image-20200311142947299" loading="lazy"></figure>
<pre><code class="language-js">&lt;% if (post.abstract) { %&gt;
	&lt;!-- 有手动摘要则加个more链接 --&gt;
	&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;more →&lt;/a&gt;
&lt;% } else if (site.customConfig.is_auto_excerpt) { %&gt;
	&lt;!-- 没有手动摘要切开启了自动摘要,则根据配置筛除摘要内容 --&gt;
	&lt;% var br_position = 0 %&gt;
	&lt;% for (var br_count = 0; br_count &lt; site.customConfig.auto_excerpt_line; br_count++) { %&gt;
		&lt;% br_position = post.content.indexOf('\n',br_position + 1) %&gt;
		&lt;% if(br_position &lt; 0) { break } %&gt;
	&lt;% } %&gt;
	&lt;% if(br_position &gt; 0) { %&gt;
		&lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;
			&lt;% if(post.content.substring(0, br_position + 1).indexOf(&quot;&lt;code&quot;) &gt; 0) { %&gt;
				&lt;!-- 自动摘要出来的内容有&lt;code则补上结尾,防止格式错误 --&gt;
				&lt;/code&gt;&lt;/pre&gt;
			&lt;% } %&gt;
		&lt;p&gt;
		&lt;!-- 加个more链接 --&gt;
		&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;more →&lt;/a&gt;
	&lt;% } %&gt;
&lt;% } %&gt;
</code></pre>
<h2 id="3保存重启gridea预览查看效果">3.保存重启Gridea预览查看效果</h2>
<h2 id="4优化">4.优化</h2>
<p>接下来是一个小优化,调整了一下<code>more →</code>的的样式,看起来更顺眼一些.</p>
<p>编辑文件<code>%Gridea%\themes\simple\assets\styles\main.less</code>在最后添加:</p>
<pre><code class="language-css">.post-item .left .post-abstract a {
  color: #4c6ef5;
  border-bottom: 1px dotted #4c6ef5;
  transition: all 0.3s;
}
</code></pre>
<p>效果图</p>
<figure data-type="image" tabindex="3"><img src="https://static.sunjianbo.com/gridea-auto-excerpt/image-20200311150147647.png" alt="image-20200311150147647" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WordPress文章导出迁移到Gridea]]></title>
        <id>https://www.sunjianbo.com/wordpress-to-gridea/</id>
        <link href="https://www.sunjianbo.com/wordpress-to-gridea/">
        </link>
        <updated>2020-03-10T04:12:05.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>
<p><a href="https://gridea.dev/">Gridea</a>是一个静态博客写作客户端,类似hexo,hugo等,不过可以全面图形化操作,更简单,更方便.</p>
</li>
<li>
<p>本次导出主要基于<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter">WordPress to Gridea Exporter</a>插件,是我根据<a href="https://github.com/SchumacherFM/wordpress-to-hugo-exporter/">WordPress to Hugo Exporter<br>
</a>简单修改而来,感谢原作者(<sup>人</sup>)</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>
<p><a href="https://gridea.dev/">Gridea</a>是一个静态博客写作客户端,类似hexo,hugo等,不过可以全面图形化操作,更简单,更方便.</p>
</li>
<li>
<p>本次导出主要基于<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter">WordPress to Gridea Exporter</a>插件,是我根据<a href="https://github.com/SchumacherFM/wordpress-to-hugo-exporter/">WordPress to Hugo Exporter<br>
</a>简单修改而来,感谢原作者(<sup>人</sup>)</p>
</li>
</ul>
<!-- more -->
<blockquote>
<p>注意:如果你使用了类似WP Database Backup等备份插件,记得去删除一些历史的备份文件,否则导出文件可能会很大</p>
</blockquote>
<h2 id="操作方法">操作方法</h2>
<ol>
<li>
<p>登陆wordpress后台通过快速编辑将每一篇文章的别名修改为英文,否则导出的文章会出现乱码.虽然gridea能识别,但是链接也会变成乱码,看着闹挺.<br>
<img src="https://static.sunjianbo.com/wordpress-to-gridea/alias.png" alt="alias" loading="lazy"></p>
</li>
<li>
<p>下载WordPress to Gridea Exporter并安装到wordpress上,启用.<br>
<a href="https://github.com/sunjianbo/WordPress-to-Gridea-Exporter/archive/master.zip">https://github.com/sunjianbo/WordPress-to-Gridea-Exporter/archive/master.zip</a></p>
</li>
<li>
<p>点击后台管理菜单的工具--&gt;Export to Hugo然后浏览器会自动下载一个名为hugo-export.zip的文件,所需的东西都在里面了.<br>
<img src="https://static.sunjianbo.com/wordpress-to-gridea/action.png" alt="action" loading="lazy"></p>
</li>
<li>
<p>提取hugo-export.zip文件中的posts文件下的所有md文件到Documents\Gridea\posts目录下(如果不知道该目录在那,查看Gridea的设置)</p>
</li>
<li>
<p>重启Gridea查看并预览是否已经读取到相关文章</p>
</li>
<li>
<p>wordpress中隐藏的文章全部设为草稿了,如需发布自行编辑一下</p>
</li>
<li>
<p>文章中的图片有可能需要重新处理一下,wp媒体库的图片在压缩包中wp-content/uploads目录中</p>
</li>
</ol>
]]></content>
    </entry>
</feed>